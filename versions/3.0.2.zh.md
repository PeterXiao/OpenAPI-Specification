#OpenAPI规范

####版本3.0.2

关键词“必须”，“绝不”，“必须”，“应该”，“不应该”，“应该”，“不应该”，“推荐”，“不推荐”，“可以”和“可选” “在本文件中的解释如[BCP 14]（https://tools.ietf.org/html/bcp14）[RFC2119]（https://tools.ietf.org/html/rfc2119）所述[RFC8174] ]（https://tools.ietf.org/html/rfc8174）当它们出现在所有首都时，如果显示在这里，如此处所示。

本文档根据[The Apache License，Version 2.0]（https://www.apache.org/licenses/LICENSE-2.0.html）获得许可。

＃＃ 介绍

OpenAPI规范（OAS）定义了RESTful API的标准，与语言无关的接口，允许人和计算机发现和理解服务的功能，而无需访问源代码，文档或通过网络流量检查。正确定义后，消费者可以使用最少量的实现逻辑来理解远程服务并与之交互。

然后，文档生成工具可以使用OpenAPI定义来显示API，使用各种编程语言生成服务器和客户端的代码生成工具，测试工具以及许多其他用例。

＃＃ 目录
<！ -  TOC depthFrom：1 depthTo：3 withLinks：1 updateOnSave：1 orderedList：0  - >

-  [定义]（#definition）
	-  [OpenAPI文件]（＃OpenAPI文档）
	-  [Path Templating]（#pathTemplating）
	-  [媒体类型]（＃mediaTypes）
	-  [HTTP状态代码]（#httpcode）
-  [规格]（＃规格）
	-  [版本]（＃版本）
	-  [格式]（＃格式）
	-  [文件结构]（#documentStructure）
	-  [数据类型]（#dataTypes）
	-  [RTF格式]（＃richText）
	-  [URL中的相对引用]（＃relativeReferences）
	-  [Schema]（＃schema）
		-  [OpenAPI对象]（＃oasObject）
		-  [Info Object]（＃infoObject）
		-  [联系对象]（#contactObject）
		-  [许可证对象]（#licenceObject）
		-  [服务器对象]（＃serverObject）
		-  [服务器变量对象]（＃serverVariableObject）
		-  [Components Object]（＃componentsObject）
		-  [Paths Object]（＃pathsObject）
		-  [Path Item Object]（＃pathItemObject）
		-  [操作对象]（＃operationObject）
		-  [外部文档对象]（＃externalDocumentationObject）
		-  [参数对象]（＃parameterObject）
		-  [Request Body Object]（＃requestBodyObject）
		-  [媒体类型对象]（＃mediaTypeObject）
		-  [编码对象]（#codingObject）
		-  [响应对象]（#responseObject）
		-  [响应对象]（#responseObject）
		-  [回调对象]（＃callbackObject）
		-  [示例对象]（#exampleObject）
		-  [链接对象]（#linkObject）
		-  [标题对象]（＃headerObject）
		-  [Tag Object]（＃tagObject）
		-  [参考对象]（＃referenceObject）
		-  [Schema Object]（＃schemaObject）
		-  [Discriminator Object]（＃discriminatorObject）
		-  [XML Object]（＃xmlObject）
		-  [安全方案对象]（#securitySchemeObject）
		-  [OAuth流对象]（＃oauthFlowsObject）
		-  [OAuth流对象]（＃oauthFlowObject）
		-  [安全要求对象]（#securityRequirementObject）
	-  [规范扩展]（＃specificationExtensions）
	-  [安全过滤]（#securityFiltering）
-  [附录A：修订历史]（#revisionHistory）
	

<！ -  / TOC  - >

##定义

##### <a name="oasDocument"> </a> OpenAPI文档
定义或描述API的文档（或文档集）。OpenAPI定义使用并符合OpenAPI规范。

##### <a name="pathTemplating"> </a>路径模板
路径模板是指使用花括号（{}）将URL路径的一部分标记为可使用路径参数替换。

##### <a name="mediaTypes"> </a>媒体类型
媒体类型定义分布在多个资源上。
媒体类型定义应该符合[RFC6838]（https://tools.ietf.org/html/rfc6838）。

可能的媒体类型定义的一些示例：
```
  text/plain; charset=utf-8
  application/ JSON
  application/ vnd.github + JSON
  application/ vnd.github.v3 + JSON
  application/ vnd.github.v3.raw + JSON
  application/ vnd.github.v3.text + JSON
  application/ vnd.github.v3.html + JSON
  application/ vnd.github.v3.full + JSON
  application/ vnd.github.v3.diff
  application/ vnd.github.v3.patch
```
##### <a name="httpCodes"> </a> HTTP状态代码
HTTP状态代码用于指示已执行操作的状态。 
可用的状态代码由[RFC7231]（https://tools.ietf.org/html/rfc7231#section-6）定义，注册的状态代码列在[IANA状态代码注册表]中（https：// www。 iana.org/assignments/http-status-codes/http-status-codes.xhtml）。

##规格

###版本

OpenAPI规范使用[Semantic Versioning 2.0.0]（https://semver.org/spec/v2.0.0.html）（semver）进行版本控制，并遵循semver规范。

semver的`major``minor`部分（例如`3.0`）应该指定OAS功能集。通常，*`。。patch` *版本解决了本文档中的错误，而不是功能集。支持OAS 3.0的工具应该与所有OAS 3.0。\ *版本兼容。补丁版本不应该被工具考虑，例如在“3.0.0”和“3.0.1”之间没有区别。

随后的OpenAPI规范的次要版本发布（增加`minor`版本号）不应该干扰开发到较低版本和相同主要版本的工具。因此，假设的“3.1.0”规范应该适用于为“3.0.0”设计的工具。

与OAS 3。\ *。\ *兼容的OpenAPI文档包含必需的[`openapi`]（＃oasVersion）字段，该字段指定它使用的OAS的语义版本。（OAS 2.0文档包含名为[`swagger`]的顶级版本字段（https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#swaggerObject），值为“2.0” `。）

###格式

符合OpenAPI规范的OpenAPI文档本身就是一个JSON对象，可以用JSON或YAML格式表示。

例如，如果字段具有数组值，则将使用JSON数组表示：

```JSON
{
   "field":[1,2,3]
}
```
规范中的所有字段名称都是区分大小写**。
这包括在映射中用作键的所有字段，除非明确指出键不区分大小写**。

该架构公开了两种类型的字段：固定字段，其具有声明的名称，以及图案化字段，其声明字段名称的正则表达式模式。

图案化的字段必须在包含对象中具有唯一的名称。 

为了保持YAML和JSON格式之间往返的能力，建议使用YAML版本[1.2]（http://www.yaml.org/spec/1.2/spec.html）以及一些其他约束：

- 标签必须限于[JSON Schema规则集]允许的标签（http://www.yaml.org/spec/1.2/spec.html#id2803231）。
-  YAML映射中使用的密钥必须限制为标量字符串，如[YAML故障安全模式规则集]（http://yaml.org/spec/1.2/spec.html#id2802346）所定义。

**注意：**虽然API可以由YAML或JSON格式的OpenAPI文档定义，但API请求和响应正文以及其他内容不需要是JSON或YAML。

### <a name="documentStructure"> </a>文档结构

OpenAPI文档可以由单个文档组成，也可以由用户自行决定分成多个连接的部分。在后一种情况下，必须在规范中使用`$ ref`字段，以便从[JSON Schema]（http://json-schema.org）定义中引用这些部分。

建议将根OpenAPI文档命名为：`openapi.json`或`openapi.yaml`。

### <a name="dataTypes"> </a>数据类型

OAS中的原始数据类型基于[JSON Schema Specification Wright Draft 00]（https://tools.ietf.org/html/draft-wright-json-schema-00#section-4.2）支持的类型。 
注意，也支持`integer`作为类型，并且定义为没有分数或指数部分的JSON数。 
不支持`null`作为一种类型（参见[`nullable`]（＃schemaNullable）作为替代解决方案）。
模型是使用[Schema Object]（＃schemaObject）定义的，它是JSON Schema Specification Wright Draft 00的扩展子集。

<a name="dataTypeFormat"> </a>基元有一个可选的修饰符属性：`format`。
OAS使用几种已知格式来详细定义所使用的数据类型。
但是，为了支持文档需求，`format`属性是一个开放的`字符串'值属性，可以有任何值。
可以使用诸如“email”，“uuid”等等的格式，即使本规范未定义也可以使用。
不带有`format`属性的类型遵循JSON Schema中的类型定义。不识别特定`format`的工具可以单独默认返回`type`，就像没有指定`format`一样。

美洲组织定义的格式是：

[`type`]（＃dataTypes）| [`format`]（＃dataTypeFormat）| 评论
------ | -------- | --------
`integer` | `int32` | 签名32位
`integer` | `int64` | 签名64位（又名长）
`号`| `float` | |
`号`| `double` | |
`string` | | |
`string` | `byte` | base64编码的字符
`string` | `binary` | 任何八位组序列
`boolean` | | |
`string` | `date` | 由“完整日期” -  [RFC3339]（https://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14）定义
`string` | `date-time` | 由`date-time`定义 -  [RFC3339]（https://xml2rfc.ietf.org/public/rfc/html/rfc3339.html#anchor14）
`string` | `密码`| UI提示隐藏输入。


### <a name="richText"> </a> RTF格式
在整个规范中，`description`字段被标记为支持CommonMark markdown格式。
在OpenAPI工具呈现富文本的情况下，它必须至少支持[CommonMark 0.27]（http://spec.commonmark.org/0.27/）所述的降价语法。工具可以选择忽略一些CommonMark功能来解决安全问题。

### <a name="relativeReferences"> </a> URL中的相对引用

除非另有说明，否则所有URL属性都可以是[RFC3986]（https://tools.ietf.org/html/rfc3986#section-4.2）定义的相对引用。
使用[`Server Object`]（＃serverObject）中定义的URL作为基URI解析相对引用。

`$ ref`中使用的相对引用按照[JSON Reference]（https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03）进行处理，使用当前文档的URL作为基URI。另请参见[Reference Object]（＃referenceObject）。

###架构

在下面的描述中，如果字段没有明确地**要求**或用MUST或SHALL描述，则可以认为是可选的。

#### <a name="oasObject"> </a> OpenAPI对象

这是[OpenAPI文档]（＃oasDocument）的根文档对象。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="oasVersion"> </a> openapi | `string` | **需要**。该字符串必须是OpenAPI文档使用的[OpenAPI规范版本]（＃版本）的[语义版本号]（https://semver.org/spec/v2.0.0.html）。工具规范和客户端应该使用`openapi`字段来解释OpenAPI文档。这与API [`info.version`]（＃infoVersion）字符串无关*。
<a name="oasInfo"> </a>信息| [Info Object]（＃infoObject）| **需要**。提供有关API的元数据。元数据可以根据需要由工具使用。
<a name="oasServers"> </a>服务器| [[服务器对象]（＃serverObject）] | 一组服务器对象，它们为目标服务器提供连接信息。如果没有提供`servers`属性，或者是一个空数组，则默认值为[服务器对象]（#serverObject），其[url]（＃serverUrl）值为`/`。
<a name="oasPaths"> </a>路径| [Paths Object]（＃pathsObject）| **需要**。API的可用路径和操作。
<a name="oasComponents"> </a>组件| [Components Object]（＃componentsObject）| 用于保存规范的各种模式的元素。
<a name="oasSecurity"> </a>安全性| [[安全要求对象]（#securityRequirementObject）] | 声明可以在API中使用哪些安全机制。值列表包括可以使用的备用安全要求对象。只需要满足一个安全要求对象来授权请求​​。单个操作可以覆盖此定义。
<a name="oasTags"> </a>标记| [[Tag Object]（＃tagObject）] | 规范使用的标记列表以及其他元数据。标签的顺序可用于通过解析工具反映其顺序。并非所有[Operation Object]（＃operationObject）使用的标记都必须声明。未声明的标签可以随机组织，也可以根据工具的逻辑组织。列表中的每个标记名称必须是唯一的。
<a name="oasExternalDocs"> </a> externalDocs | [外部文档对象]（＃externalDocumentationObject）| 其他外部文件。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#### <a name="infoObject"> </a>信息对象

该对象提供有关API的元数据。
如果需要，客户端可以使用元数据，为方便起见，可以在编辑或文档生成工具中显示元数据。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="infoTitle"> </a>标题| `string` | **需要**。申请的标题。
<a name="infoDescription"> </a>说明| `string` | 应用程序的简短描述。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="infoTermsOfService"> </a> termsOfService | `string` | API的服务条款的URL。必须采用URL的格式。
<a name="infoContact"> </a>与...联系 [Contact Object]（＃contactObject）| 公开的API的联系信息。
<a name="infoLicense"> </a>许可证| [许可证对象]（＃licenseObject）| 公开的API的许可证信息。
<a name="infoVersion"> </a>版本| `string` | **需要**。OpenAPI文档的版本（不同于[OpenAPI规范版本]（＃oasVersion）或API实现版本）。


可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

##### Info对象示例

```JSON
{
  "title": "Sample Pet Store App",
  "description": "This is a sample server for a pet store.",
  "termsOfService": "http://example.com/terms/",
  "contact": {
    "name": "API Support",
    "url": "http://www.example.com/support",
    "email": "support@example.com"
  },
  "license": {
    "name": "Apache 2.0",
    "url": "https://www.apache.org/licenses/LICENSE-2.0.html"
  },
  "version": "1.0.1"
}
```

```YAML
title: Sample Pet Store App
description: This is a sample server for a pet store.
termsOfService: http://example.com/terms/
contact:
  name: API Support
  url: http://www.example.com/support
  email: support@example.com
license:
  name: Apache 2.0
  url: https://www.apache.org/licenses/LICENSE-2.0.html
version: 1.0.1

```

#### <a name="contactObject"> </a>联系对象

已公开API的联系信息。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="contactName"> </a>名称| `string` | 联系人/组织的识别名称。
<a name="contactUrl"> </a>网址| `string` | 指向联系信息的URL。必须采用URL的格式。
<a name="contactEmail"> </a>电子邮件| `string` | 联系人/组织的电子邮件地址。必须采用电子邮件地址的格式。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####联系对象示例

```JSON
{
  "name": "API Support",
  "url": "http://www.example.com/support",
  "email": "support@example.com"
}
```

```YAML
name: API Support
url: http://www.example.com/support
email: support@example.com
```

#### <a name="licenseObject"> </a>许可对象

公开的API的许可证信息。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="licenseName"> </a>名称| `string` | **需要**。用于API的许可证名称。
<a name="licenseUrl"> </a>网址| `string` | 用于API的许可证的URL。必须采用URL的格式。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####许可证对象示例

```JSON
{
  "name": "Apache 2.0",
  "url": "https://www.apache.org/licenses/LICENSE-2.0.html"
}

```

```YAML
name: Apache 2.0
url: https://www.apache.org/licenses/LICENSE-2.0.html
```

#### <a name="serverObject"> </a>服务器对象

表示服务器的对象。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="serverUrl"> </a>网址| `string` | **需要**。目标主机的URL。此URL支持服务器变量并且可以是相对的，以指示主机位置相对于提供OpenAPI文档的位置。当变量在`{`bracket`}`中命名时，将进行变量替换。
<a name="serverDescription"> </a>说明| `string` | 描述URL指定的主机的可选字符串。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="serverVariables"> </a>变量| Map [`string`，[Server Variable Object]（＃serverVariableObject）] | 变量名称及其值之间的映射。该值用于在服务器的URL模板中进行替换。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####服务器对象示例

单个服务器将被描述为：

```JSON
{
  "url": "https://development.gigantic-server.com/v1",
  "description": "Development server"
}}
```

```YAML
url: https://development.gigantic-server.com/v1
description: Development server
```

下面显示了如何描述多个服务器，例如，在OpenAPI对象的[`servers`]（＃oasServers）中：

```JSON
{
  "servers": [
    {
      "url": "https://development.gigantic-server.com/v1",
      "description": "Development server"
    },
    {
      "url": "https://staging.gigantic-server.com/v1",
      "description": "Staging server"
    },
    {
      "url": "https://api.gigantic-server.com/v1",
      "description": "Production server"
    }
  ]
}
```

```YAML
servers:
- url: https://development.gigantic-server.com/v1
  description: Development server
- url: https://staging.gigantic-server.com/v1
  description: Staging server
- url: https://api.gigantic-server.com/v1
  description: Production server
```

以下显示了变量如何用于服务器配置：

```JSON
{
  "servers": [
    {
      "url": "https://{username}.gigantic-server.com:{port}/{basePath}",
      "description": "The production API server",
      "variables": {
        "username": {
          "default": "demo",
          "description": "this value is assigned by the service provider, in this example `gigantic-server.com`"
        },
        "port": {
          "enum": [
            "8443",
            "443"
          ],
          "default": "8443"
        },
        "basePath": {
          "default": "v2"
        }
      }
    }
  ]
}
```

```YAML
servers:
- url: https://{username}.gigantic-server.com:{port}/{basePath}
  description: The production API server
  variables:
    username:
      # note! no enum here means it is an open value
      default: demo
      description: this value is assigned by the service provider, in this example `gigantic-server.com`
    port:
      enum:
        - '8443'
        - '443'
      default: '8443'
    basePath:
      # open meaning there is the opportunity to use special base paths as assigned by the provider, default is `v2`
      default: v2
```


#### <a name="serverVariableObject"> </a>服务器变量对象

表示服务器URL模板替换的服务器变量的对象。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="serverVariableEnum"> </a>枚举| [`string`] | 如果替换选项来自有限集，则使用字符串值的枚举。
<a name="serverVariableDefault"> </a>默认值| `string` | **需要**。用于替换的默认值，如果提供了备用值，则应发送该默认值。请注意，此行为与默认值的[Schema Object]（＃schemaObject）处理不同，因为在这些情况下，参数值是可选的。
<a name="serverVariableDescription"> </a>说明| `string` | 服务器变量的可选描述。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#### <a name="componentsObject"> </a>组件对象

为OAS的不同方面保留一组可重用对象。
组件对象中定义的所有对象都不会对API产生任何影响，除非它们是从组件对象外部的属性显式引用的。


#####固定字段

字段名称| 输入| 描述
--- |：--- | ---
<a name="componentsSchemas"> </a>架构| Map [`string`，[Schema Object]（＃schemaObject）\ | [参考对象]（＃referenceObject）] | 一个保存可重用[Schema Objects]（＃schemaObject）的对象。
<a name="componentsResponses"> </a>回复| Map [`string`，[Response Object]（＃responseObject）\ | [参考对象]（＃referenceObject）] | 保存可重用[Response Objects]（#responseObject）的对象。
<a name="componentsParameters"> </a>参数| Map [`string`，[Parameter Object]（＃parameterObject）\ | [参考对象]（＃referenceObject）] | 保存可重用[参数对象]（＃parameterObject）的对象。
<a name="componentsExamples"> </a>示例| Map [`string`，[Example Object]（＃exampleObject）\ | [参考对象]（＃referenceObject）] | 保持可重用[对象]（#exampleObject）的对象。
<a name="componentsRequestBodies"> </a> requestBodies | Map [`string`，[Request Body Object]（＃requestBodyObject）\ | [参考对象]（＃referenceObject）] | 保存可重用[Request Body Objects]（＃requestBodyObject）的对象。
<a name="componentsHeaders"> </a>标题| Map [`string`，[Header Object]（＃headerObject）\ | [参考对象]（＃referenceObject）] | 一个保存可重用[Header Objects]（＃headerObject）的对象。
<a name="componentsSecuritySchemes"> </a> securitySchemes | Map [`string`，[Security Scheme Object]（＃securitySchemeObject）\ | [参考对象]（＃referenceObject）] | 保存可重用[安全方案对象]（#securitySchemeObject）的对象。
<a name="componentsLinks"> </a>链接| Map [`string`，[Link Object]（＃linkObject）\ | [参考对象]（＃referenceObject）] | 保持可重用[链接对象]（#linkObject）的对象。
<a name="componentsCallbacks"> </a>回调| Map [`string`，[Callback Object]（＃callbackObject）\ | [参考对象]（＃referenceObject）] | 一个保存可重用[Callback Objects]（＃callbackObject）的对象。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

上面声明的所有固定字段都是必须使用与正则表达式匹配的键的对象：`^ [a-zA-Z0-9 \。\ -_] + $`。

字段名称示例：

```
User
User_1
User_Name
user-name
my.org.User
```

#####组件对象示例

```JSON
"components": {
  "schemas": {
    "GeneralError": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        }
      }
    },
    "Category": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "Tag": {
      "type": "object",
      "properties": {
        "id": {
          "type": "integer",
          "format": "int64"
        },
        "name": {
          "type": "string"
        }
      }
    }
  },
  "parameters": {
    "skipParam": {
      "name": "skip",
      "in": "query",
      "description": "number of items to skip",
      "required": true,
      "schema": {
        "type": "integer",
        "format": "int32"
      }
    },
    "limitParam": {
      "name": "limit",
      "in": "query",
      "description": "max records to return",
      "required": true,
      "schema" : {
        "type": "integer",
        "format": "int32"
      }
    }
  },
  "responses": {
    "NotFound": {
      "description": "Entity not found."
    },
    "IllegalInput": {
      "description": "Illegal input for operation."
    },
    "GeneralError": {
      "description": "General Error",
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/GeneralError"
          }
        }
      }
    }
  },
  "securitySchemes": {
    "api_key": {
      "type": "apiKey",
      "name": "api_key",
      "in": "header"
    },
    "petstore_auth": {
      "type": "oauth2",
      "flows": {
        "implicit": {
          "authorizationUrl": "http://example.org/api/oauth/dialog",
          "scopes": {
            "write:pets": "modify pets in your account",
            "read:pets": "read your pets"
          }
        }
      }
    }
  }
}
```

```YAML
components:
  schemas:
    GeneralError:
      type: object
      properties:
        code:
          type: integer
          format: int32
        message:
          type: string
    Category:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
    Tag:
      type: object
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
  parameters:
    skipParam:
      name: skip
      in: query
      description: number of items to skip
      required: true
      schema:
        type: integer
        format: int32
    limitParam:
      name: limit
      in: query
      description: max records to return
      required: true
      schema:
        type: integer
        format: int32
  responses:
    NotFound:
      description: Entity not found.
    IllegalInput:
      description: Illegal input for operation.
    GeneralError:
      description: General Error
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/GeneralError'
  securitySchemes:
    api_key:
      type: apiKey
      name: api_key
      in: header
    petstore_auth:
      type: oauth2
      flows: 
        implicit:
          authorizationUrl: http://example.org/api/oauth/dialog
          scopes:
            write:pets: modify pets in your account
            read:pets: read your pets

```


#### <a name="pathsObject"> </a>路径对象

保存各个端点及其操作的相对路径。
该路径将附加到[`Server Object`]（＃serverObject）的URL中，以构造完整的URL。由于[ACL约束]（#securityFiltering），路径可能为空。

#####图案化字段

场模式| 输入| 描述
--- |：---：| ---
<a name="pathsPath"> </a> / {path} | [Path Item Object]（＃pathItemObject）| 单个端点的相对路径。字段名称必须以斜杠开头。路径**从[`Server Object`]（＃serverObject）的`url`字段附加**（没有相对URL解析）到扩展的URL，以构造完整的URL。允许[路径模板]（#pathTemplating）。匹配URL时，具体（非模板化）路径将在其模板化对应物之前进行匹配。具有相同层次但具有不同模板名称的模板化路径不能存在，因为它们是相同的。如果模糊匹配，则由工具决定使用哪一个。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####路径模板匹配

假设有以下路径，具体定义`/ pets / mine`将首先匹配使用：

```
  /pets/{petId}
  /pets/mine
```

以下路径被视为相同且无效：

```
    /pets/{petId}
    /pets/{name}
```

以下可能会导致模糊的解决方案：

```
  /{entity}/me
  /books/{id}
```

#####路径对象示例

```JSON
{
  "/pets": {
    "get": {
      "description": "Returns all pets from the system that the user has access to",
      "responses": {
        "200": {          
          "description": "A list of pets.",
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/pet"
                }
              }
            }
          }
        }
      }
    }
  }
}}
```

```YAML
/pets:
  get:
    description: Returns all pets from the system that the user has access to
    responses:
      '200':
        description: A list of pets.
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/pet'
```

#### <a name="pathItemObject"> </a>路径项对象

描述单个路径上可用的操作。
由于[ACL约束]（#securityFiltering），路径项可能为空。
路径本身仍然暴露给文档查看器，但他们不知道哪些操作和参数可用。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="pathItemRef"> </a> $ ref | `string` | 允许此路径项的外部定义。引用的结构必须采用[Path Item Object]（＃pathItemObject）的格式。如果引用的定义与此Path Item的定义之间存在冲突，则行为为* undefined *。
<a name="pathItemSummary"> </a>摘要| `string` | 一个可选的字符串摘要，旨在应用于此路径中的所有操作。
<a name="pathItemDescription"> </a>说明| `string` | 可选的字符串描述，旨在应用于此路径中的所有操作。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="pathItemGet"> </a>获取| [Operation Object]（＃operationObject）| 此路径上的GET操作的定义。
<a name="pathItemPut"> </a>放置了| [Operation Object]（＃operationObject）| 此路径上的PUT操作的定义。
<a name="pathItemPost"> </a>发布| [Operation Object]（＃operationObject）| 此路径上的POST操作的定义。
<a name="pathItemDelete"> </a>删除| [Operation Object]（＃operationObject）| 此路径上DELETE操作的定义。
<a name="pathItemOptions"> </a>选项| [Operation Object]（＃operationObject）| 此路径上的OPTIONS操作的定义。
<a name="pathItemHead"> </a> head | [Operation Object]（＃operationObject）| 此路径上HEAD操作的定义。
<a name="pathItemPatch"> </a>补丁| [Operation Object]（＃operationObject）| 此路径上的PATCH操作的定义。
<a name="pathItemTrace"> </a>跟踪| [Operation Object]（＃operationObject）| 此路径上的TRACE操作的定义。
<a name="pathItemServers"> </a>服务器| [[服务器对象]（＃serverObject）] | 另一个`server`数组，用于为此路径中的所有操作提供服务。
<a name="pathItemParameters"> </a>参数| [[Parameter Object]（＃parameterObject）\ | [参考对象]（＃referenceObject）] | 适用于此路径下描述的所有操作的参数列表。这些参数可以在操作级别覆盖，但不能在那里删除。该列表不得包含重复的参数。唯一参数由[name]（＃parameterName）和[location]（＃parameterIn）的组合定义。该列表可以使用[Reference Object]（＃referenceObject）链接到[OpenAPI Object的组件/参数]（＃componentsParameters）中定义的参数。


可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####路径项对象示例

```JSON
{
  "get": {
    "description": "Returns pets based on ID",
    "summary": "Find pets by ID",
    "operationId": "getPetsById",
    "responses": {
      "200": {
        "description": "pet response",
        "content": {
          "*/*": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/Pet"
              }
            }
          }
        }
      },
      "default": {
        "description": "error payload",
        "content": {
          "text/html": {
            "schema": {
              "$ref": "#/components/schemas/ErrorModel"
            }
          }
        }
      }
    }
  },
  "parameters": [
    {
      "name": "id",
      "in": "path",
      "description": "ID of pet to use",
      "required": true,
      "schema": {
        "type": "array",
        "items": {
          "type": "string"
        }
      },
      "style": "simple"
    }
  ]
}

```

```YAML
get:
  description: Returns pets based on ID
  summary: Find pets by ID
  operationId: getPetsById
  responses:
    '200':
      description: pet response
      content:
        '*/*' :
          schema:
            type: array
            items:
              $ref: '#/components/schemas/Pet'
    default:
      description: error payload
      content:
        'text/html':
          schema:
            $ref: '#/components/schemas/ErrorModel'
parameters:
- name: id
  in: path
  description: ID of pet to use
  required: true
  schema:
    type: array
    style: simple
    items:
      type: string  
```

#### <a name="operationObject"> </a>操作对象

描述路径上的单个API操作。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="operationTags"> </a>标记| [`string`] | API文档控制的标记列表。标签可用于按资源或任何其他限定符对操作进行逻辑分组。
<a name="operationSummary"> </a>摘要| `string` | 操作的简短摘要。
<a name="operationDescription"> </a>说明| `string` | 操作行为的详细解释。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="operationExternalDocs"> </a> externalDocs | [外部文档对象]（＃externalDocumentationObject）| 此操作的其他外部文档。
<a name="operationId"> </a> operationId | `string` | 用于标识操作的唯一字符串。id必须在API中描述的所有操作中是唯一的。operationId值是**区分大小写的**。工具和库可以使用operationId来唯一标识操作，因此，建议遵循常见的编程命名约定。
<a name="operationParameters"> </a>参数| [[Parameter Object]（＃parameterObject）\ | [参考对象]（＃referenceObject）] | 适用于此操作的参数列表。如果已在[Path Item]（#pathItemParameters）中定义了参数，则新定义将覆盖它，但永远不能删除它。该列表不得包含重复的参数。唯一参数由[name]（＃parameterName）和[location]（＃parameterIn）的组合定义。该列表可以使用[Reference Object]（＃referenceObject）链接到[OpenAPI Object的组件/参数]（＃componentsParameters）中定义的参数。
<a name="operationRequestBody"> </a> requestBody | [Request Body Object]（＃requestBodyObject）\ | [参考对象]（＃referenceObject）| 请求正文适用于此操作。只有HTTP 1.1方法支持`requestBody`，其中HTTP 1.1规范[RFC7231]（https://tools.ietf.org/html/rfc7231#section-4.3.1）明确定义了请求体的语义。在HTTP规范含糊不清的其他情况下，消费者应忽略“requestBody”。
<a name="operationResponses"> </a>回复| [Responses Object]（#responseObject）| **需要**。执行此操作时返回的可能响应列表。
<a name="operationCallbacks"> </a>回调| Map [`string`，[Callback Object]（＃callbackObject）\ | [参考对象]（＃referenceObject）] | 与父操作相关的可能的带外回调映射。密钥是回调对象的唯一标识符。映射中的每个值都是[Callback Object]（＃callbackObject），它描述了可由API提供程序发起的请求和预期的响应。用于标识回调对象的键值是在运行时计算的表达式，该表达式标识用于回调操作的URL。
不推荐使用<a name="operationDeprecated"> </a> `boolean` | 声明此操作不推荐使用。消费者应该避免使用声明的操作。默认值为“false”。
<a name="operationSecurity"> </a>安全性| [[安全要求对象]（#securityRequirementObject）] | 声明可以将此安全机制用于此操作。值列表包括可以使用的备用安全要求对象。只需要满足一个安全要求对象来授权请求​​。该定义覆盖任何声明的顶级[`security`]（＃oasSecurity）。要删除顶级安全声明，可以使用空数组。
<a name="operationServers"> </a>服务器| [[服务器对象]（＃serverObject）] | 另一个`server`数组来为这个操作提供服务。如果在Path Item Object或Root级别指定了另一个`server`对象，则该值将被它覆盖。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####操作对象示例

```JSON
{
  "tags": [
    "pet"
  ],
  "summary": "Updates a pet in the store with form data",
  "operationId": "updatePetWithForm",
  "parameters": [
    {
      "name": "petId",
      "in": "path",
      "description": "ID of pet that needs to be updated",
      "required": true,
      "schema": {
        "type": "string"
      }
    }
  ],
  "requestBody": {
    "content": {
      "application/x-www-form-urlencoded": {
        "schema": {
          "type": "object",
           "properties": {
              "name": { 
                "description": "Updated name of the pet",
                "type": "string"
              },
              "status": {
                "description": "Updated status of the pet",
                "type": "string"
             }
           },
        "required": ["status"] 
        }
      }
    }
  },
  "responses": {
    "200": {
      "description": "Pet updated.",
      "content": {
        "application/json": {},
        "application/xml": {}
      }
    },
    "405": {
      "description": "Method Not Allowed",
      "content": {
        "application/json": {},
        "application/xml": {}
      }
    }
  },
  "security": [
    {
      "petstore_auth": [
        "write:pets",
        "read:pets"
      ]
    }
  ]
}
```

```YAML
tags:
- pet
summary: Updates a pet in the store with form data
operationId: updatePetWithForm
parameters:
- name: petId
  in: path
  description: ID of pet that needs to be updated
  required: true
  schema:
    type: string
requestBody:
  content:
    'application/x-www-form-urlencoded':
      schema:
       properties:
          name: 
            description: Updated name of the pet
            type: string
          status:
            description: Updated status of the pet
            type: string
       required:
         - status
responses:
  '200':
    description: Pet updated.
    content: 
      'application/json': {}
      'application/xml': {}
  '405':
    description: Method Not Allowed
    content: 
      'application/json': {}
      'application/xml': {}
security:
- petstore_auth:
  - write:pets
  - read:pets
```


#### <a name="externalDocumentationObject"> </a>外部文档对象

允许引用外部资源以扩展文档。

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="externalDocDescription"> </a>说明| `string` | 目标文档的简短描述。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="externalDocUrl"> </a>网址| `string` | **需要**。目标文档的URL。值必须采用URL的格式。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####外部文档对象示例

```JSON
{
  "description": "Find more info here",
  "url": "https://example.com"
}
```

```YAML
description: Find more info here
url: https://example.com
```

#### <a name="parameterObject"> </a>参数对象

描述单个操作参数。

唯一参数由[name]（＃parameterName）和[location]（＃parameterIn）的组合定义。

#####参数位置
`in`字段指定了四个可能的参数位置：
* path  - 与[Path Templating]（#pathTemplating）一起使用，其中参数值实际上是操作URL的一部分。这不包括API的主机或基本路径。例如，在`/ items / {itemId}`中，path参数是`itemId`。
* query  - 附加到URL的参数。例如，在`/ items？id = ###`中，查询参数是`id`。
* header  - 作为请求的一部分预期的自定义标头。请注意，[RFC7230]（https://tools.ietf.org/html/rfc7230#page-22）声明标头名称不区分大小写。
* cookie  - 用于将特定的cookie值传递给API。


#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="parameterName"> </a>名称| `string` | **需要**。参数的名称。参数名称*区分大小写*。<ul> <li>如果[`in`]（＃parameterIn）是`“path”`，`name`字段必须对应于[Paths对象]中[path]（＃pathsPath）字段的关联路径段]（＃pathsObject）。有关详细信息，请参阅[Path Templating]（＃pathTemplating）。<li>如果[`in`]（＃parameterIn）是``header``并且`name`字段是`“Accept”`，``Content-Type “`或``Authorization”`，参数定义应该被忽略。<li>对于所有其他情况，`name`对应于[`in`]（＃parameterIn）属性使用的参数名。</ ul >
在|中<a name="parameterIn"> </a> `string` | **需要**。参数的位置。可能的值是“query”，“header”，“path”或“cookie”。
<a name="parameterDescription"> </a>说明| `string` | 参数的简要说明。这可能包含使用示例。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
需要<a name="parameterRequired"> </a> `boolean` | 确定此参数是否必需。如果[parameter location]（＃parameterIn）是“path”，则此属性为** REQUIRED **且其值必须为“true”。否则，可以包含属性，其默认值为“false”。
不推荐使用<a name="parameterDeprecated"> </a> `boolean` | 指定不推荐使用参数，并且应该将其从使用中转换出来。默认值为“false”。
<a name="parameterAllowEmptyValue"> </a> allowEmptyValue | `boolean` | 设置传递空值参数的功能。这仅对`query`参数有效，并允许发送带空值的参数。默认值为“false”。如果使用[`style`]（＃parameterStyle），并且行为是'n / a`（不能序列化），则应忽略`allowEmptyValue`的值。不推荐使用此属性，因为它可能会在以后的版本中删除。

参数序列化的规则以两种方式之一指定。
对于更简单的场景，[`schema`]（＃parameterSchema）和[`style`]（＃parameterStyle）可以描述参数的结构和语法。

字段名称| 输入| 描述
--- |：---：| ---
<a name="parameterStyle"> </a> style | `string` | 描述如何根据参数值的类型序列化参数值。默认值（基于`in`的值）：对于`query`  - `form`; 对于`path`  - `simple`; 对于`header`  - `simple`; 对于`cookie`  - `form`。
<a name="parameterExplode"> </a>爆炸| `boolean` | 当这是真的时，类型为`array`或`object`的参数值为数组的每个值或映射的键值对生成单独的参数。对于其他类型的参数，此属性无效。当[`style`]（＃parameterStyle）是`form`时，默认值为`true`。对于所有其他样式，默认值为“false”。
<a name="parameterAllowReserved"> </a> allowReserved | `boolean` | 确定参数值是否应该允许保留字符，由[RFC3986]（https://tools.ietf.org/html/rfc3986#section-2.2）`：/？＃[] @！$＆'（）*定义+ ,; =`包含没有百分比编码。此属性仅适用于```值为`query`的参数。默认值为“false”。
<a name="parameterSchema"> </a>架构| [Schema Object]（＃schemaObject）\ | [参考对象]（＃referenceObject）| 定义用于参数的类型的模式。
<a name="parameterExample"> </a>示例| 任何| 媒体类型的示例。该示例应该与指定的模式和编码属性匹配（如果存在）。`example`字段与`examples`字段互斥。此外，如果引用包含示例的`schema`，那么`example`值应该是由模式提供的示例。要表示无法在JSON或YAML中自然表示的媒体类型的示例，字符串值可以包含必要时进行转义的示例。
<a name="parameterExamples"> </a>示例| Map [`string`，[Example Object]（＃exampleObject）\ | [参考对象]（＃referenceObject）] | 媒体类型的示例。每个示例应该包含参数编码中指定的正确格式的值。`examples`字段与`example`字段互斥。此外，如果引用包含示例的`schema`，那么`examples`值应该是由模式提供的示例。

对于更复杂的场景，[`content`]（＃parameterContent）属性可以定义参数的媒体类型和架构。
参数必须包含`schema`属性或`content`属性，但不能同时包含两者。
当`example`或`examples`与`schema`对象一起提供时，该示例必须遵循参数的规定序列化策略。


字段名称| 输入| 描述
--- |：---：| ---
<a name="parameterContent"> </a>内容| Map [`string`，[Media Type Object]（＃mediaTypeObject）] | 包含参数表示的映射。关键是媒体类型，值描述它。地图必须只包含一个条目。

#####样式值

为了支持序列化简单参数的常用方法，定义了一组`style`值。

`style` | [`type`]（＃dataTypes）| `in` | 评论
----------- ------ | -------- | --------
矩阵| `primitive`，`array`，`object` | `path` | 由[RFC6570]定义的路径样式参数（https://tools.ietf.org/html/rfc6570#section-3.2.7）
标签| `primitive`，`array`，`object` | `path` | 由[RFC6570]定义的标签样式参数（https://tools.ietf.org/html/rfc6570#section-3.2.5）
形式| `primitive`，`array`，`object` | `query`，`cookie` | 由[RFC6570]定义的表单样式参数（https://tools.ietf.org/html/rfc6570#section-3.2.8）。此选项将“collectionFormat”替换为来自OpenAPI 2.0的`csv`（当`explode`为false时）或`multi`（当`explode`为true时）值。
简单| `array` | `path`，`header` | 由[RFC6570]定义的简单样式参数（https://tools.ietf.org/html/rfc6570#section-3.2.2）。此选项将“collectionFormat”替换为OpenAPI 2.0中的`csv`值。
spaceDelimited | `array` | `query` | 空格分隔的数组值。此选项从OpenAPI 2.0替换`collectionFormat`等于`ssv`。
pipeDelimited | `array` | `query` | 管道分隔的数组值。此选项将替换`collectionFormat`等于来自OpenAPI 2.0的`pipes`。
deepObject | `object` | `query` | 提供使用表单参数呈现嵌套对象的简单方法。


#####样式示例

假设名为“color”的参数具有以下值之一：

```
   string -> "blue"
   array -> ["blue","black","brown"]
   object -> { "R": 100, "G": 200, "B": 150 }
```
下表显示了每个值的渲染差异示例。

[`style`]（＃dataTypeFormat）| `爆炸`| `empty` | `string` | `array` | `object`
----------- ------ | -------- | -------- | -------- | -------
矩阵| 假| ;颜色| ; color = blue | ; color =蓝色，黑色，棕色| ;颜色= R，100，G，200，B，150
矩阵| 是的| ;颜色| ; color = blue | ; color = blue; color = black; color = brown | ; R = 100; G = 200，B = 150
标签| 假| 。| .blue | .blue.black.brown | .R.100.G.200.B.150
标签| 是的| 。| .blue | .blue.black.brown | .R = 100.G = 200.B = 150
形式| 假| color = | color = blue | color =蓝色，黑色，棕色| 颜色= R，100，G，200，B，150
形式| 是的| color = | color = blue | color = blue＆color = black＆color = brown | R = 100，G = 200 B = 150
简单| 假| 不适用| 蓝色| 蓝色，黑色，棕色| R，100，G，200，B，150
简单| 是的| 不适用| 蓝色| 蓝色，黑色，棕色| R = 100，G = 200，B = 150
spaceDelimited | 假| 不适用| 不适用| blue％20black％20brown | R％20100％20G％20200％20B％20150
pipeDelimited | 假| 不适用| 不适用| 蓝色\ |黑色\ |棕色| r \ | 100 \ | G \ | 200 | G \ | 150
deepObject | 是的| 不适用| 不适用| 不适用| 颜色[R] = 100＆颜色[G] = 200＆颜色[B] = 150

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####参数对象示例

头参数，数组为64位整数：

```JSON
{
  "name": "token",
  "in": "header",
  "description": "token to be passed as a header",
  "required": true,
  "schema": {
    "type": "array",
    "items": {
      "type": "integer",
      "format": "int64"
    }
  },
  "style": "simple"
}
```

```YAML
name: token
in: header
description: token to be passed as a header
required: true
schema:
  type: array
  items:
    type: integer
    format: int64
style: simple
```

字符串值的路径参数：
```JSON
{
  "name": "username",
  "in": "path",
  "description": "username to fetch",
  "required": true,
  "schema": {
    "type": "string"
  }
}
```

```YAML
name: username
in: path
description: username to fetch
required: true
schema:
  type: string
```

字符串值的可选查询参数，通过重复查询参数允许多个值：
```JSON
{
  "name": "id",
  "in": "query",
  "description": "ID of the object to fetch",
  "required": false,
  "schema": {
    "type": "array",
    "items": {
      "type": "string"
    }
  },
  "style": "form",
  "explode": true
}
```

```YAML
name: id
in: query
description: ID of the object to fetch
required: false
schema:
  type: array
  items:
    type: string
style: form
explode: true
```

自由格式查询参数，允许特定类型的未定义参数：
```JSON
{
  "in": "query",
  "name": "freeForm",
  "schema": {
    "type": "object",
    "additionalProperties": {
      "type": "integer"
    },
  },
  "style": "form"
}
```

```YAML
in: query
name: freeForm
schema:
  type: object
  additionalProperties:
    type: integer
style: form
```

使用`content`定义序列化的复杂参数：

```JSON
{
  "in": "query",
  "name": "coordinates",
  "content": {
    "application/json": {
      "schema": {
        "type": "object",
        "required": [
          "lat",
          "long"
        ],
        "properties": {
          "lat": {
            "type": "number"
          },
          "long": {
            "type": "number"
          }
        }
      }
    }
  }
}
```

```YAML
in: query
name: coordinates
content:
  application/json:
    schema:
      type: object
      required:
        - lat
        - long
      properties:
        lat:
          type: number
        long:
          type: number
```

#### <a name="requestBodyObject"> </a>请求正文对象

描述单个请求正文。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="requestBodyDescription"> </a>说明| `string` | 请求正文的简要说明。这可能包含使用示例。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="requestBodyContent"> </a>内容| Map [`string`，[Media Type Object]（＃mediaTypeObject）] | **需要**。请求正文的内容。关键是媒体类型或[媒体类型范围]（https://tools.ietf.org/html/rfc7231#appendix-D），该值描述它。对于匹配多个密钥的请求，只有最具体的密钥适用。例如text / plain覆盖text / *
需要<a name="requestBodyRequired"> </a> `boolean` | 确定请求中是否需要请求正文。默认为“false”。


可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####请求正文示例

具有引用模型定义的请求主体。
```JSON
{
  "description": "user to add to the system",
  "content": {
    "application/json": {
      "schema": {
        "$ref": "#/components/schemas/User"
      },
      "examples": {
          "user" : {
            "summary": "User Example", 
            "externalValue": "http://foo.bar/examples/user-example.json"
          } 
        }
    },
    "application/xml": {
      "schema": {
        "$ref": "#/components/schemas/User"
      },
      "examples": {
          "user" : {
            "summary": "User example in XML",
            "externalValue": "http://foo.bar/examples/user-example.xml"
          }
        }
    },
    "text/plain": {
      "examples": {
        "user" : {
            "summary": "User example in Plain text",
            "externalValue": "http://foo.bar/examples/user-example.txt" 
        }
      } 
    },
    "*/*": {
      "examples": {
        "user" : {
            "summary": "User example in other format",
            "externalValue": "http://foo.bar/examples/user-example.whatever"
        }
      }
    }
  }
}
```

```YAML
description: user to add to the system
content: 
  'application/json':
    schema:
      $ref: '#/components/schemas/User'
    examples:
      user:
        summary: User Example
        externalValue: 'http://foo.bar/examples/user-example.json'
  'application/xml':
    schema:
      $ref: '#/components/schemas/User'
    examples:
      user:
        summary: User Example in XML
        externalValue: 'http://foo.bar/examples/user-example.xml'
  'text/plain':
    examples:
      user:
        summary: User example in text plain format
        externalValue: 'http://foo.bar/examples/user-example.txt'
  '*/*':
    examples:
      user: 
        summary: User example in other format
        externalValue: 'http://foo.bar/examples/user-example.whatever'
```

一个body参数，它是一个字符串值数组：
```JSON
{
  "description": "user to add to the system",
  "content": {
    "text/plain": {
      "schema": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    }
  }
}
```

```YAML
description: user to add to the system
required: true
content:
  text/plain:
    schema:
      type: array
      items:
        type: string
```


#### <a name="mediaTypeObject"> </a>媒体类型对象
每个媒体类型对象提供由其键标识的媒体类型的架构和示例。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="mediaTypeSchema"> </a>架构| [Schema Object]（＃schemaObject）\ | [参考对象]（＃referenceObject）| 定义请求，响应或参数内容的模式。
<a name="mediaTypeExample"> </a>示例| 任何| 媒体类型的示例。示例对象应该采用媒体类型指定的正确格式。`example`字段与`examples`字段互斥。此外，如果引用包含示例的`schema`，那么`example`值应该是由模式提供的示例。
<a name="mediaTypeExamples"> </a>示例| Map [`string`，[Example Object]（＃exampleObject）\ | [参考对象]（＃referenceObject）] | 媒体类型的示例。每个示例对象应该匹配媒体类型和指定的模式（如果存在）。`examples`字段与`example`字段互斥。此外，如果引用包含示例的`schema`，那么`examples`值应该是由模式提供的示例。
<a name="mediaTypeEncoding"> </a>编码| Map [`string`，[Encoding Object]（＃encodingObject）] | 属性名称与其编码信息之间的映射。密钥作为属性名称，必须作为属性存在于模式中。当媒体类型为“multipart”或“application / x-www-form-urlencoded”时，编码对象仅适用于`requestBody`对象。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####媒体类型示例

```JSON
{
  "application/json": {
    "schema": {
         "$ref": "#/components/schemas/Pet"
    },
    "examples": {
      "cat" : {
        "summary": "An example of a cat",
        "value": 
          {
            "name": "Fluffy",
            "petType": "Cat",
            "color": "White",
            "gender": "male",
            "breed": "Persian"
          }
      },
      "dog": {
        "summary": "An example of a dog with a cat's name",
        "value" :  { 
          "name": "Puma",
          "petType": "Dog",
          "color": "Black",
          "gender": "Female",
          "breed": "Mixed"
        },
      "frog": {
          "$ref": "#/components/examples/frog-example"
        }
      }
    }
  }
}
```

```YAML
application/json: 
  schema:
    $ref: "#/components/schemas/Pet"
  examples:
    cat:
      summary: An example of a cat
      value:
        name: Fluffy
        petType: Cat
        color: White
        gender: male
        breed: Persian
    dog:
      summary: An example of a dog with a cat's name
      value:
        name: Puma
        petType: Dog
        color: Black
        gender: Female
        breed: Mixed
    frog:
      $ref: "#/components/examples/frog-example"
```

#####文件上传的注意事项

与2.0规范相比，OpenAPI中的`file`输入/输出内容使用与任何其他模式类型相同的语义进行描述。特别：

```YAML
# content transferred with base64 encoding
schema:
  type: string
  format: base64
```

```YAML
# content transferred in binary (octet-stream):
schema:
  type: string
  format: binary
```

这些示例适用于文件上载或响应有效负载的输入有效负载。

用于在`POST`操作中提交文件的`requestBody`可能类似于以下示例：

```YAML
requestBody:
  content:
    application/octet-stream:
      # any media type is accepted, functionally equivalent to `*/*`
      schema:
        # a binary file of any type
        type: string
        format: binary
```

此外，可以指定特定的媒体类型：

```YAML
# multiple, specific media types may be specified:
requestBody:
  content:
      # a binary file of type png or jpeg
    'image/jpeg':
      schema:
        type: string
        format: binary
    'image/png':
      schema:
        type: string
        format: binary            
```

要上传多个文件，必须使用`multipart`媒体类型：

```YAML
requestBody:
  content:
    multipart/form-data:
      schema:
        properties:
          # The property name 'file' will be used for all files.
          file:
            type: array
            items:
              type: string
              format: binary

```

#####支持x-www-form-urlencoded请求机构

要通过[RFC1866]（https://tools.ietf.org/html/rfc1866）使用表单网址编码提交内容，请执行以下操作
可以使用以下定义：

```YAML
requestBody:
  content:
    application/x-www-form-urlencoded:
      schema:
        type: object
        properties:
          id:
            type: string
            format: uuid
          address:
            # complex types are stringified to support RFC 1866
            type: object
            properties: {}
```

在这个例子中，`requestBody`中的内容必须按照[RFC1866]（https://tools.ietf.org/html/rfc1866/）进行字符串化，然后传递给服务器。另外，`address`字段复杂对象将被字符串化。

在`application / x-www-form-urlencoded`内容类型中传递复杂对象时，这些属性的默认序列化策略在[`Encoding Object`]（#codingObject）的[`style`]中描述（＃ encodingStyle属性为`form`。

#####“multipart”内容的特殊注意事项

在将请求主体转移到操作时，通常使用`multipart / form-data`作为`Content-Type`。与2.0相反，当使用`multipart`内容时，需要`schema`来定义操作的输入参数。这支持复杂的结构以及多文件上载的支持机制。

当传入`multipart`类型时，可以使用边界来分隔正在传输的内容的部分 - 因此，为`multipart`定义了以下默认的`Content-Type`：

*如果属性是基元或原始值数组，则默认的Content-Type为`text / plain`
*如果属性很复杂，或者是复数值数组，则默认的Content-Type是`application / json`
*如果属性是`type：string`，格式为：binary`或`format：base64`（又名文件对象），则默认的Content-Type为`application / octet-stream`


例子：

```YAML
requestBody:
  content:
    multipart/form-data:
      schema:
        type: object
        properties:
          id:
            type: string
            format: uuid
          address:
            # default Content-Type for objects is `application/json`
            type: object
            properties: {}
          profileImage:
            # default Content-Type for string/binary is `application/octet-stream`
            type: string
            format: binary
          children:
            # default Content-Type for arrays is based on the `inner` type (text/plain here)
            type: array
            items:
              type: string
          addresses:
            # default Content-Type for arrays is based on the `inner` type (object shown, so `application/json` in this example)
            type: array
            items:
              type: '#/components/schemas/Address'
```

引入了`encoding`属性，可以控制`multipart`请求体的部分序列化。此属性_only_适用于`multipart`和`application / x-www-form-urlencoded`请求正文。

#### <a name="encodingObject"> </a>编码对象

应用于单个架构属性的单个编码定义。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="encodingContentType"> </a> contentType | `string` | 用于编码特定属性的Content-Type。默认值取决于属性类型：对于`string`，`format`为`binary`  - `application / octet-stream`; 对于其他原始类型 - “text / plain”; 对于`object`  - `application / json`; 对于`array`  - 默认是根据内部类型定义的。该值可以是特定媒体类型（例如`application / json`），通配符媒体类型（例如`image / *`），或两种类型的逗号分隔列表。
<a name="encodingHeaders"> </a>标题| Map [`string`，[Header Object]（＃headerObject）\ | [参考对象]（＃referenceObject）] | 允许以标题提供附加信息的映射，例如“Content-Disposition”。“Content-Type”单独描述，在本节中应忽略。如果请求正文媒体类型不是“multipart”，则应忽略此属性。
<a name="encodingStyle"> </a> style | `string` | 描述如何根据类型序列化特定属性值。有关[`style`]（＃parameterStyle）属性的详细信息，请参见[Parameter Object]（＃parameterObject）。该行为遵循与`query`参数相同的值，包括默认值。如果请求正文媒体类型不是`application / x-www-form-urlencoded`，则应忽略此属性。
<a name="encodingExplode"> </a>爆炸| `boolean` | 当这是真的时，类型为`array`或`object`的属性值为数组的每个值或映射的键值对生成单独的参数。对于其他类型的属性，此属性无效。当[`style`]（＃encodingStyle）是`form`时，默认值为`true`。对于所有其他样式，默认值为“false”。如果请求正文媒体类型不是`application / x-www-form-urlencoded`，则应忽略此属性。
<a name="encodingAllowReserved"> </a> allowReserved | `boolean` | 确定参数值是否应该允许保留字符，由[RFC3986]（https://tools.ietf.org/html/rfc3986#section-2.2）`：/？＃[] @！$＆'（）*定义+ ,; =`包含没有百分比编码。默认值为“false”。如果请求正文媒体类型不是`application / x-www-form-urlencoded`，则应忽略此属性。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####编码对象示例

```YAML
requestBody:
  content:
    multipart/mixed:
      schema:
        type: object
        properties:
          id:
            # default is text/plain
            type: string
            format: uuid
          address:
            # default is application/json
            type: object
            properties: {}
          historyMetadata:
            # need to declare XML format!
            description: metadata in XML format
            type: object
            properties: {}
          profileImage:
            # default is application/octet-stream, need to declare an image type only!
            type: string
            format: binary
      encoding:
        historyMetadata:
          # require XML Content-Type in utf-8 encoding
          contentType: application/xml; charset=utf-8
        profileImage:
          # only accept png/jpeg
          contentType: image/png, image/jpeg
          headers:
            X-Rate-Limit-Limit:
              description: The number of allowed requests in the current period
              schema:
                type: integer
```

#### <a name="responsesObject"> </a>回复对象

用于操作的预期响应的容器。
容器将HTTP响应代码映射到预期响应。

预计文档不一定涵盖所有可能的HTTP响应代码，因为它们可能不会提前知道。
但是，文档预计将涵盖成功的操作响应和任何已知错误。

`default`可以用作所有HTTP代码的默认响应对象 
规范未单独涵盖的内容。

`Responses Object`必须包含至少一个响应代码 
应该是成功的操作呼叫的响应。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="responsesDefault"> </a>默认值| [Response Object]（＃responseObject）\ | [参考对象]（＃referenceObject）| 除了为特定HTTP响应代码声明的响应之外的响应的文档。使用此字段涵盖未申报的回复。[Reference Object]（＃referenceObject）可以链接到[OpenAPI Object的组件/响应]（＃componentsResponses）部分定义的响应。

#####图案化字段
场模式| 输入| 描述
--- |：---：| ---
<a name="responsesCode"> </a> [HTTP状态代码]（#httpcode）| [Response Object]（＃responseObject）\ | [参考对象]（＃referenceObject）| 任何[HTTP状态代码]（#httpcode）都可以用作属性名称，但每个代码只能使用一个属性来描述该HTTP状态代码的预期响应。[Reference Object]（＃referenceObject）可以链接到[OpenAPI Object的组件/响应]（＃componentsResponses）部分中定义的响应。为了JSON和YAML之间的兼容性，该字段必须用引号括起来（例如，“200”）。要定义一系列响应代码，该字段可以包含大写通配符“X”。例如，`2XX`代表`[200-299]`之间的所有响应代码。只允许以下范围定义：`1XX`，`2XX`，`3XX`，`4XX`和`5XX`。


可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####响应对象示例

成功操作的响应为200，其他操作的默认响应（表示错误）：

```JSON
{
  "200": {
    "description": "a pet to be returned",
    "content": {
      "application/json": {
        "schema": {
          "$ref": "#/components/schemas/Pet"
        }
      }
    }
  },
  "default": {
    "description": "Unexpected error",
    "content": {
      "application/json": {
        "schema": {
          "$ref": "#/components/schemas/ErrorModel"
        }
      }
    }
  }
}
```

```YAML
'200':
  description: a pet to be returned
  content: 
    application/json:
      schema:
        $ref: '#/components/schemas/Pet'
default:
  description: Unexpected error
  content:
    application/json:
      schema:
        $ref: '#/components/schemas/ErrorModel'
```

#### <a name="responseObject"> </a>响应对象
描述API操作的单个响应，包括设计时静态 
`链接`基于响应的操作。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="responseDescription"> </a>说明| `string` | **需要**。响应的简短描述。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="responseHeaders"> </a>标题| Map [`string`，[Header Object]（＃headerObject）\ | [参考对象]（＃referenceObject）] | 将标题名称映射到其定义。[RFC7230]（https://tools.ietf.org/html/rfc7230#page-22）声明标头名称不区分大小写。如果使用名称“Content-Type”定义响应头，则应忽略它。
<a name="responseContent"> </a>内容| Map [`string`，[Media Type Object]（＃mediaTypeObject）] | 包含潜在响应有效负载描述的地图。关键是媒体类型或[媒体类型范围]（https://tools.ietf.org/html/rfc7231#appendix-D），该值描述它。对于匹配多个密钥的响应，只有最具体的密钥适用。例如text / plain覆盖text / *
<a name="responseLinks"> </a>链接| Map [`string`，[Link Object]（＃linkObject）\ | [参考对象]（＃referenceObject）] | 可以从响应中获取的操作链接映射。根据[组件对象]（＃componentsObject）的名称的命名约束，映射的键是链接的简称。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####响应对象示例

复杂类型数组的响应：

```JSON
{
  "description": "A complex object array response",
  "content": {
    "application/json": {
      "schema": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/VeryComplexType"
        }
      }
    }
  }
}
```

```YAML
description: A complex object array response
content: 
  application/json:
    schema: 
      type: array
      items:
        $ref: '#/components/schemas/VeryComplexType'
```

响应字符串类型：

```JSON
{
  "description": "A simple string response",
  "content": {
    "text/plain": {
      "schema": {
        "type": "string"
      }
    }
  }

}
```

```YAML
description: A simple string response
content:
  text/plain:
    schema:
      type: string
```

带标题的纯文本响应：

```JSON
{
  "description": "A simple string response",
  "content": {
    "text/plain": {
      "schema": {
        "type": "string"
      }
    }
  },
  "headers": {
    "X-Rate-Limit-Limit": {
      "description": "The number of allowed requests in the current period",
      "schema": {
        "type": "integer"
      }
    },
    "X-Rate-Limit-Remaining": {
      "description": "The number of remaining requests in the current period",
      "schema": {
        "type": "integer"
      }
    },
    "X-Rate-Limit-Reset": {
      "description": "The number of seconds left in the current period",
      "schema": {
        "type": "integer"
      }
    }
  }
}
```

```YAML
description: A simple string response
content:
  text/plain:
    schema:
      type: string
    example: 'whoa!'
headers:
  X-Rate-Limit-Limit:
    description: The number of allowed requests in the current period
    schema:
      type: integer
  X-Rate-Limit-Remaining:
    description: The number of remaining requests in the current period
    schema:
      type: integer
  X-Rate-Limit-Reset:
    description: The number of seconds left in the current period
    schema:
      type: integer
```

没有返回值的响应：

```JSON
{
  "description": "object created"
}
```

```YAML
description: object created
```

#### <a name="callbackObject"> </a>回调对象

与父操作相关的可能的带外回调映射。
映射中的每个值都是[Path Item Object]（#pathItemObject），它描述了可由API提供程序发起的一组请求和预期的响应。
用于标识回调对象的键值是在运行时计算的表达式，该表达式标识用于回调操作的URL。

#####图案化字段
场模式| 输入| 描述
--- |：---：| ---
<a name="callbackExpression"> </a> {expression} | [Path Item Object]（＃pathItemObject）| Path Item Object用于定义回调请求和预期响应。可以使用[完整示例]（../ examples / v3.0 / callback-example.yaml）。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####关键表达

标识[Path Item Object]（#pathItemObject）的键是[runtime expression]（＃runtimeExpression），可以在运行时HTTP请求/响应的上下文中对其进行评估，以标识要用于回调请求的URL。
一个简单的例子可能是`$ request.body＃/ url`。
但是，使用[运行时表达式]（＃runtimeExpression）可以访问完整的HTTP消息。
这包括访问JSON指针[RFC6901]（https://tools.ietf.org/html/rfc6901）可以引用的正文的任何​​部分。 

例如，给定以下HTTP请求：

```HTTP
POST /subscribe/myevent?queryUrl=http://clientdomain.com/stillrunning HTTP/1.1
Host: example.org
Content-Type: application/json
Content-Length: 187

{
  "failedUrl" : "http://clientdomain.com/failed",
  "successUrls" : [
    "http://clientdomain.com/fast",
    "http://clientdomain.com/medium",
    "http://clientdomain.com/slow"
  ] 
}

201 Created
Location: http://example.org/subscription/1
```

假设回调操作具有名为`eventType`的路径参数和名为`queryUrl`的查询参数，以下示例显示各种表达式如何计算。

表达| 值
--- |：---
$ url | http://example.org/subscribe/myevent?queryUrl=http://clientdomain.com/stillrunning
$ method | POST
$ request.path.eventType | myevent
$ request.query.queryUrl | http://clientdomain.com/stillrunning
$ request.header.content-Type | 应用程序/ JSON
$ request.body＃/ failedUrl | http://clientdomain.com/failed
$ request.body＃/ successUrls / 2 | http://clientdomain.com/medium
$ response.header.Location | http://example.org/subscription/1


#####回调对象示例

以下示例显示了对请求正文中`id`和`email`属性指定的URL的回调。

```YAML
myWebhook:
  'http://notificationServer.com?transactionId={$request.body#/id}&email={$request.body#/email}':
    post:
      requestBody:
        description: Callback payload
        content: 
          'application/json':
            schema:
              $ref: '#/components/schemas/SomePayload'
      responses:
        '200':
          description: webhook successfully processed and no retries will be performed
```


#### <a name="exampleObject"> </a>示例对象

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="exampleSummary"> </a>摘要| `string` | 该示例的简短描述。
<a name="exampleDescription"> </a>说明| `string` | 该示例的详细描述。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="exampleValue"> </a>值| 任何| 嵌入式文字示例。`value`字段和`externalValue`字段是互斥的。要表示无法在JSON或YAML中自然表示的媒体类型的示例，请使用字符串值来包含示例，并在必要时进行转义。
<a name="exampleExternalValue"> </a> externalValue | `string` | 指向文字示例的URL。这提供了引用无法轻松包含在JSON或YAML文档中的示例的功能。`value`字段和`externalValue`字段是互斥的。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

在所有情况下，示例值都应与类型模式兼容 
其相关价值。工具实现可以选择
自动验证兼容性，如果不兼容则拒绝示例值。

#####示例对象示例

在模型中：

```YAML
schemas:
  properties:
    name:
      type: string
      examples:
        name:
          $ref: http://example.org/petapi-examples/openapi.json#/components/examples/name-example
```

在请求正文中：

```YAML
requestBody:
  content:
    'application/json':
      schema:
        $ref: '#/components/schemas/Address'
      examples: 
        foo:
          summary: A foo example
          value: {"foo": "bar"}
        bar:
          summary: A bar example
          value: {"bar": "baz"}
    'application/xml':
      examples: 
        xmlExample:
          summary: This is an example in XML
          externalValue: 'http://example.org/examples/address-example.xml'
    'text/plain':
      examples:
        textExample: 
          summary: This is a text example
          externalValue: 'http://foo.bar/examples/address-example.txt'
```

在参数中：

```YAML
parameters:
  - name: 'zipCode'
    in: 'query'
    schema:
      type: 'string'
      format: 'zip-code'
      examples:
        zip-example: 
          $ref: '#/components/examples/zip-example'
```

在回复中：

```YAML
responses:
  '200':
    description: your car appointment has been booked
    content: 
      application/json:
        schema:
          $ref: '#/components/schemas/SuccessResponse'
        examples:
          confirmation-success:
            $ref: '#/components/examples/confirmation-success'
```


#### <a name="linkObject"> </a>链接对象

“链接对象”表示响应的可能设计时链接。
链接的存在并不能保证调用者成功调用它的能力，而是在响应和其他操作之间提供已知的关系和遍历机制。

与_dynamic_ links（即**响应有效负载中提供的链接）不同，OAS链接机制不需要运行时响应中的链接信息。

对于计算链接并提供执行它们的指令，[运行时表达式]（＃runtimeExpression）用于访问操作中的值并在调用链接操作时将它们用作参数。  

#####固定字段

字段名称| 输入| 描述
--- |：---：| ---
<a name="linkOperationRef"> </a> operationRef | `string` | 对OAS操作的相对或绝对引用。该字段与`operationId`字段互斥，并且必须指向[Operation Object]（＃operationObject）。相对`operationRef`值可用于定位OpenAPI定义中的现有[Operation Object]（＃operationObject）。
<a name="linkOperationId"> </a> operationId | `string` | _existing_，resolvable OAS操作的名称，由唯一的`operationId`定义。该字段与`operationRef`字段互斥。  
<a name="linkParameters"> </a>参数| Map [`string`，Any \ | [{expression}]（＃runtimeExpression）] | 一个映射，表示传递给使用`operationId`指定的操作或通过`operationRef`识别的操作的参数。键是要使用的参数名称，而值可以是常量或要计算并传递给链接操作的表达式。对于在不同位置使用相同参数名称的操作（例如path.id），可以使用[parameter location]（＃parameterIn）`[{in}。] {name}`来限定参数名称。
<a name="linkRequestBody"> </a> requestBody | 任何\ | [{expression}]（＃runtimeExpression）| 在调用目标操作时用作请求主体的文字值或[{表达式}]（＃runtimeExpression）。
<a name="linkDescription"> </a>说明| `string` | 链接的描述。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="linkServer"> </a>服务器| [服务器对象]（＃serverObject）| 目标操作要使用的服务器对象。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

必须使用`operationRef`或`operationId`来识别链接的操作。
在`operationId`的情况下，它必须是唯一的，并在OAS文档的范围内解决。
由于名称冲突的可能性，首选`operationRef`语法 
适用于带外部参考的规格。

＃＃＃＃＃ 例子

计算来自请求操作的链接，其中`$ request.path.id`用于将请求参数传递给链接操作。

```YAML
paths:
  /users/{id}:
    parameters:
    - name: id
      in: path
      required: true
      description: the user identifier, as userId 
      schema:
        type: string
    get:
      responses:
        '200':
          description: the user being returned
          content:
            application/json:
              schema:
                type: object
                properties:
                  uuid: # the unique user id
                    type: string
                    format: uuid
          links:
            address:
              # the target link operationId
              operationId: getUserAddress
              parameters:
                # get the `id` field from the request path parameter named `id`
                userId: $request.path.id
  # the path item of the linked operation
  /users/{userid}/address:
    parameters:
    - name: userid
      in: path
      required: true
      description: the user identifier, as userId 
      schema:
        type: string
    # linked operation
    get:
      operationId: getUserAddress
      responses:
        '200':
          description: the user's address
```

如果运行时表达式无法计算，则不会将任何参数值传递给目标操作。

响应主体中的值可用于驱动链接操作。

```YAML
links:
  address:
    operationId: getUserAddressByUUID
    parameters:
      # get the `uuid` field from the `uuid` field in the response body
      userUuid: $response.body#/uuid
```

客户可自行决定是否遵循所有链接。 
无法保证权限，也无法成功调用该链接 
完全靠存在关系。


##### OperationRef示例

由于对`operationId`的引用是不可能的（`operationId`是可选的 
值），引用也可以通过相对`operationRef`来进行：

```YAML
links:
  UserRepositories:
    # returns array of '#/components/schemas/repository'
    operationRef: '#/paths/~12.0~1repositories~1{username}/get'
    parameters:
      username: $response.body#/username
```

或绝对的`operationRef`：

```YAML
links:
  UserRepositories:
    # returns array of '#/components/schemas/repository'
    operationRef: 'https://na2.gigantic-server.com/#/paths/~12.0~1repositories~1{username}/get'
    parameters:
      username: $response.body#/username
```

注意，在使用`operationRef`时，_escaped forward-slash_是必要的 
使用JSON引用。


##### <a name="runtimeExpression"> </a>运行时表达式

运行时表达式允许基于仅在实际API调用中的HTTP消息中可用的信息来定义值。
[Link Objects]（#linkObject）和[Callback Objects]（＃callbackObject）使用此机制。

运行时表达式由以下[ABNF]（https://tools.ietf.org/html/rfc5234）语法定义

```
      expression = ( "$url" | "$method" | "$statusCode" | "$request." source | "$response." source )
           source = ( header-reference | query-reference | path-reference | body-reference )  
           header-reference = "header." token
           query-reference = "query." name  
           path-reference = "path." name
           body-reference = "body" ["#" fragment]
           fragment = a JSON Pointer [RFC 6901](https://tools.ietf.org/html/rfc6901)  
           name = *( char )
           char = as per RFC [7159](https://tools.ietf.org/html/rfc7159#section-7)
           token = as per RFC [7230](https://tools.ietf.org/html/rfc7230#section-3.2.6)
```

`name`标识符区分大小写，而`token`则不区分大小写。 

下表提供了运行时表达式的示例以及它们在值中的使用示例：

##### <a name="runtimeExpressionExamples"> </a>示例

来源地点| 示例表达式| 笔记
--- |：--- |：--- |
HTTP方法| `$ method` | `$ method`的允许值将是HTTP操作的允许值。
请求的媒体类型| `$ request.header.accept` |  
请求参数| `$ request.path.id` | 请求参数必须在父操作的`parameters`部分声明，否则无法计算它们。这包括请求标头。
请求身体属性| `$ request.body＃/ user / uuid` | 在接受有效载荷的操作中，可以对“requestBody”的部分或整个主体进行引用。
请求网址| `$ url` |  
响应值| `$ response.body＃/ status` | 在返回有效载荷的操作中，可以对响应主体的部分或整个主体进行引用。
响应头| `$ response.header.Server` | 单个标头值仅可用

运行时表达式保留引用值的类型。
通过用“{}”花括号括起表达式，可以将表达式嵌入到字符串值中。

#### <a name="headerObject"> </a>标头对象

Header对象遵循[Parameter Object]（＃parameterObject）的结构，并进行以下更改：

1.`name`不能指定，它在相应的`headers`映射中给出。
1.`in`不能指定，它隐含在`header`中。
1.受该位置影响的所有特征必须适用于`header`的位置（例如，[`style`]（＃parameterStyle））。

#####标头对象示例

一个简单的“整数”类型的标题：

```JSON
{
  "description": "The number of allowed requests in the current period",
  "schema": {
    "type": "integer"
  }
}
```

```YAML
description: The number of allowed requests in the current period
schema:
  type: integer
```

#### <a name="tagObject"> </a>标记对象

将元数据添加到[Operation Object]（＃operationObject）使用的单个标记中。
在操作对象实例中定义每个标记的标记对象不是必需的。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="tagName"> </a>名称| `string` | **需要**。标签的名称。
<a name="tagDescription"> </a>说明| `string` | 标签的简短描述。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="tagExternalDocs"> </a> externalDocs | [外部文档对象]（＃externalDocumentationObject）| 此标记的其他外部文档。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####标记对象示例

```JSON
{
	"name": "pet",
	"description": "Pets operations"
}
```

```YAML
name: pet
description: Pets operations
```


#### <a name="referenceObject"> </a>参考对象

一个简单的对象，允许在内部和外部引用规范中的其他组件。

参考对象由[JSON参考]（https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03）定义，并遵循相同的结构，行为和规则。 

对于此规范，参考分辨率是由JSON参考规范定义的，而不是由JSON Schema规范定义的。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="referenceRef"> </a> $ ref | `string` | **需要**。参考字符串。

无法使用其他属性扩展此对象，并且应忽略添加的任何属性。

#####参考对象示例

```JSON
{
	"$ref": "#/components/schemas/Pet"
}
```

```YAML
$ref: '#/components/schemas/Pet'
```

#####相对模式文档示例
```JSON
{
  "$ref": "Pet.json"
}
```

```YAML
$ref: Pet.yaml
```

#####具有嵌入式架构示例的相关文档
```JSON
{
  "$ref": "definitions.json#/Pet"
}

```

```YAML
$ref: definitions.yaml#/Pet
```

#### <a name="schemaObject"> </a>架构对象

Schema Object允许定义输入和输出数据类型。
这些类型可以是对象，也可以是基元和数组。
该对象是[JSON Schema Specification Wright Draft 00]（http://json-schema.org/）的扩展子集。

有关这些属性的更多信息，请参阅[JSON模式核心]（https://tools.ietf.org/html/draft-wright-json-schema-00）和[JSON模式验证]（https：//tools.ietf .ORG / HTML /草案 - 赖特 -  JSON架构验证-00）。
除非另有说明，否则属性定义遵循JSON模式。

#####属性 

以下属性直接取自JSON Schema定义，并遵循相同的规范：

- 标题
-  multipleOf
- 最大值
-  exclusiveMaximum
- 最低
-  exclusiveMinimum
- 最长长度
-  minLength
-  pattern（根据[ECMA 262正则表达式]（https://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5）方言，此字符串应该是有效的正则表达式）
-  maxItems
-  minItems
-  uniqueItems
-  maxProperties
-  minProperties
- 必填
- 枚举

以下属性取自JSON Schema定义，但其定义已调整为OpenAPI规范。 
-  type  -  Value必须是一个字符串。不支持通过数组的多种类型。
-  allOf  - 内联或引用的模式必须是[模式对象]（＃schemaObject）而不是标准的JSON模式。
-  oneOf  - 内联或引用的模式必须是[模式对象]（＃schemaObject）而不是标准的JSON模式。
-  anyOf  - 内联或引用的模式必须是[模式对象]（＃schemaObject）而不是标准的JSON模式。
-  not  - 内联或引用的模式必须是[Schema Object]（＃schemaObject）而不是标准的JSON Schema。
-  items  -  Value必须是一个对象而不是一个数组。内联或引用的模式必须是[模式对象]（＃schemaObject）而不是标准的JSON模式。如果`type`是`array`，`items`必须存在。
-  properties  - 属性定义必须是[Schema Object]（＃schemaObject）而不是标准JSON Schema（内联或引用）。
-  additionalProperties  - 值可以是布尔值或对象。内联或引用的模式必须是[模式对象]（＃schemaObject）而不是标准的JSON模式。与JSON Schema一致，`additionalProperties`默认为`true`。
-  description  -  [CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
-  format  - 有关详细信息，请参阅[Data Type Formats]（＃dataTypeFormat）。在依赖JSON Schema定义的格式的同时，OAS提供了一些额外的预定义格式。
-  default  - 默认值表示输入的使用者将假定的内容，如果未提供输入，则将其作为模式的值。与JSON Schema不同，值必须符合在同一级别定义的Schema Object的已定义类型。例如，如果`type`是`string`，那么`default`可以是``foo“`但不能是`1`。

或者，只要可以使用模式对象，就可以在其位置使用[参考对象]（＃referenceObject）。这允许引用定义而不是内联定义它们。

此处未提及的JSON模式规范定义的其他属性严格不受支持。

除了JSON Schema子集字段之外，以下字段可用于进一步的模式文档：

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="schemaNullable"> </a>可以为空| `boolean` | 允许为定义的模式发送“null”值。默认值为“false”。
<a name="schemaDiscriminator"> </a>鉴别符| [Discriminator Object]（＃discriminatorObject）| 添加对多态性的支持。鉴别符是一个对象名，用于区分可能满足有效负载描述的其他模式。有关更多详细信息，请参见[组合和继承]（＃schemaComposition）。
<a name="schemaReadOnly"> </a> readOnly | `boolean` | 仅与Schema“属性”定义相关。将属性声明为“只读”。这意味着它可以作为响应的一部分发送，但不应作为请求的一部分发送。如果属性被标记为`readOnly`为`true`并且在`required`列表中，则'required`将仅对响应生效。属性不能被标记为`readOnly`和`writeOnly`都是`true`。默认值为“false”。
<a name="schemaWriteOnly"> </a> writeOnly | `boolean` | 仅与Schema“属性”定义相关。将属性声明为“只写”。因此，它可以作为请求的一部分发送，但不应作为响应的一部分发送。如果属性被标记为`writeOnly`为`true`并且在`required`列表中，则'required`将仅对请求生效。属性不能被标记为`readOnly`和`writeOnly`都是`true`。默认值为“false”。
<a name="schemaXml"> </a> xml | [XML Object]（＃xmlObject）| 这可能只在属性模式上使用。它对根模式没有影响。添加其他元数据以描述此属性的XML表示形式。
<a name="schemaExternalDocs"> </a> externalDocs | [外部文档对象]（＃externalDocumentationObject）| 此架构的其他外部文档。
<a name="schemaExample"> </a>示例| 任何| 一个自由格式的属性，包含此架构的实例示例。要表示无法在JSON或YAML中自然表示的示例，可以使用字符串值来包含必要时进行转义的示例。
不推荐使用<a name="schemaDeprecated"> </a> `boolean` | 指定不推荐使用架构，并且应该将其从使用中转换出来。默认值为“false”。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

###### <a name="schemaComposition"> </a>组成和继承（多态）

OpenAPI规范允许使用JSON Schema的`allOf`属性组合和扩展模型定义，实际上提供了模型组合。
`allOf`采用一系列对象定义，这些对象定义独立验证*但是一起组成一个对象。 

虽然组合提供了模型可扩展性，但它并不意味着模型之间的层次结构。
为了支持多态性，OpenAPI规范添加了`discriminator`字段。
使用时，`discriminator`将是属性的名称，它决定哪个模式定义验证模型的结构。
因此，“discriminator”字段必须是必填字段。
有两种方法可以为继承实例定义鉴别器的值。
- 使用模式名称。
- 通过使用新值覆盖属性来覆盖模式名称。如果存在新值，则优先于模式名称。
因此，没有给定id的内联模式定义*不能用于多态。

###### XML建模

在将JSON定义转换为XML时，[xml]（＃schemaXml）属性允许额外的定义。
[XML Object]（＃xmlObject）包含有关可用选项的其他信息。

##### Schema Object Examples

######原始样本

```JSON
{
  "type": "string",
  "format": "email"
}
```

```YAML
type: string
format: email
```

######简单模型

```JSON
{
  "type": "object",
  "required": [
    "name"
  ],
  "properties": {
    "name": {
      "type": "string"
    },
    "address": {
      "$ref": "#/components/schemas/Address"
    },
    "age": {
      "type": "integer",
      "format": "int32",
      "minimum": 0
    }
  }
}
```

```YAML
type: object
required:
- name
properties:
  name:
    type: string
  address:
    $ref: '#/components/schemas/Address'
  age:
    type: integer
    format: int32
    minimum: 0
```

######带有地图/字典属性的模型

对于简单的字符串到字符串映射：

```JSON
{
  "type": "object",
  "additionalProperties": {
    "type": "string"
  }
}
```

```YAML
type: object
additionalProperties:
  type: string
```

对于字符串到模型映射：

```JSON
{
  "type": "object",
  "additionalProperties": {
    "$ref": "#/components/schemas/ComplexModel"
  }
}
```

```YAML
type: object
additionalProperties:
  $ref: '#/components/schemas/ComplexModel'
```

######带示例的模型

```JSON
{
  "type": "object",
  "properties": {
    "id": {
      "type": "integer",
      "format": "int64"
    },
    "name": {
      "type": "string"
    }
  },
  "required": [
    "name"
  ],
  "example": {
    "name": "Puma",
    "id": 1
  }
}
```

```YAML
type: object
properties:
  id:
    type: integer
    format: int64
  name:
    type: string
required:
- name
example:
  name: Puma
  id: 1
```

######带有Composition的模型

```JSON
{
  "components": {
    "schemas": {
      "ErrorModel": {
        "type": "object",
        "required": [
          "message",
          "code"
        ],
        "properties": {
          "message": {
            "type": "string"
          },
          "code": {
            "type": "integer",
            "minimum": 100,
            "maximum": 600
          }
        }
      },
      "ExtendedErrorModel": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ErrorModel"
          },
          {
            "type": "object",
            "required": [
              "rootCause"
            ],
            "properties": {
              "rootCause": {
                "type": "string"
              }
            }
          }
        ]
      }
    }
  }
}
```

```YAML
components:
  schemas:
    ErrorModel:
      type: object
      required:
      - message
      - code
      properties:
        message:
          type: string
        code:
          type: integer
          minimum: 100
          maximum: 600
    ExtendedErrorModel:
      allOf:
      - $ref: '#/components/schemas/ErrorModel'
      - type: object
        required:
        - rootCause
        properties:
          rootCause:
            type: string
```

######具有多态性支持的模型

```JSON
{
  "components": {
    "schemas": {
      "Pet": {
        "type": "object",
        "discriminator": {
          "propertyName": "petType"
        },
        "properties": {
          "name": {
            "type": "string"
          },
          "petType": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "petType"
        ]
      },
      "Cat": {
        "description": "A representation of a cat. Note that `Cat` will be used as the discriminator value.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Pet"
          },
          {
            "type": "object",
            "properties": {
              "huntingSkill": {
                "type": "string",
                "description": "The measured skill for hunting",
                "default": "lazy",
                "enum": [
                  "clueless",
                  "lazy",
                  "adventurous",
                  "aggressive"
                ]
              }
            },
            "required": [
              "huntingSkill"
            ]
          }
        ]
      },
      "Dog": {
        "description": "A representation of a dog. Note that `Dog` will be used as the discriminator value.",
        "allOf": [
          {
            "$ref": "#/components/schemas/Pet"
          },
          {
            "type": "object",
            "properties": {
              "packSize": {
                "type": "integer",
                "format": "int32",
                "description": "the size of the pack the dog is from",
                "default": 0,
                "minimum": 0
              }
            },
            "required": [
              "packSize"
            ]
          }
        ]
      }
    }
  }
}
```

```YAML
components:
  schemas:
    Pet:
      type: object
      discriminator:
        propertyName: petType
      properties:
        name:
          type: string
        petType:
          type: string
      required:
      - name
      - petType
    Cat:  ## "Cat" will be used as the discriminator value
      description: A representation of a cat
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        properties:
          huntingSkill:
            type: string
            description: The measured skill for hunting
            enum:
            - clueless
            - lazy
            - adventurous
            - aggressive
        required:
        - huntingSkill
    Dog:  ## "Dog" will be used as the discriminator value
      description: A representation of a dog
      allOf:
      - $ref: '#/components/schemas/Pet'
      - type: object
        properties:
          packSize:
            type: integer
            format: int32
            description: the size of the pack the dog is from
            default: 0
            minimum: 0
        required:
        - packSize
```

#### <a name="discriminatorObject"> </a> Discriminator对象

当请求主体或响应有效负载可能是许多不同模式之一时，可以使用“discriminator”对象来帮助进行序列化，反序列化和验证。鉴别器是模式中的特定对象，用于基于与其相关联的值向消费者通知替代模式的规范。

使用鉴别器时，不会考虑_inline_ schemas。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="propertyName"> </a> propertyName | `string` | **需要**。有效负载中将保存鉴别器值的属性的名称。
<a name="discriminatorMapping"> </a>映射| Map [`string`，`string`] | 用于保存有效内容值和模式名称或引用之间的映射的对象。

仅当使用复合关键字“oneOf”，“anyOf”，“allOf”之一时，鉴别器对象才是合法的。

在OAS 3.0中，响应有效负载可以描述为任意数量的类型之一：

```YAML
MyResponseType：
  oneOf：
  -  $ ref：'＃/ components / schemas / Cat'
  -  $ ref：'＃/ components / schemas / Dog'
  -  $ ref：'＃/ components / schemas / Lizard'
```

这意味着有效负载_MUST_，通过验证，完全匹配“猫”，“狗”或“蜥蜴”描述的模式之一。在这种情况下，鉴别器可以充当“提示”以快速验证和选择匹配模式，这可能是昂贵的操作，这取决于模式的复杂性。然后我们可以准确地描述哪个字段告诉我们使用哪个模式：


```YAML
MyResponseType：
  oneOf：
  -  $ ref：'＃/ components / schemas / Cat'
  -  $ ref：'＃/ components / schemas / Dog'
  -  $ ref：'＃/ components / schemas / Lizard'
  鉴别：
    propertyName：petType
```

现在的期望是响应有效负载中存在名称为“petType”_MUST_的属性，该值将对应于OAS文档中定义的模式的名称。因此响应有效载荷：

```JSON
{
  “id”：12345，
  “petType”：“猫”
}
```

将指示`Cat`模式与此有效负载一起使用。

在鉴别器字段的值与模式名称不匹配或无法进行隐式映射的情况下，可以使用可选的`mapping`定义：

```YAML
MyResponseType：
  oneOf：
  -  $ ref：'＃/ components / schemas / Cat'
  -  $ ref：'＃/ components / schemas / Dog'
  -  $ ref：'＃/ components / schemas / Lizard'
  -  $ ref：'https://gigantic-server.com/schemas/Monster/schema.json'
  鉴别：
    propertyName：petType
    制图：
      狗：'＃/ components / schemas / Dog'
      怪物：'https://gigantic-server.com/schemas/Monster/schema.json'
```

这里`dog`的鉴别器_value_将映射到模式`＃/ components / schemas / Dog`，而不是`Dog`的默认（隐含）值。如果鉴别器_value_与隐式或显式映射不匹配，则无法确定任何模式，验证应该失败。映射键必须是字符串值，但工具可以将响应值转换为字符串以进行比较。

当与`anyOf`结构一起使用时，使用鉴别器可以避免模糊，其中多个模式可以满足单个有效载荷。

在`oneOf`和`anyOf`用例中，必须明确列出所有可能的模式。为了避免冗余，可以将鉴别器添加到父模式定义中，并且可以将包含“allOf”结构中的父模式的所有模式用作替代模式。

例如：

```YAML
组件：
  模式：
    宠物：
      类型：对象
      需要：
      -  petType
      特性：
        petType：
          type：string
      鉴别：
        propertyName：petType
        制图：
          狗：狗
    猫：
      所有的：
      -  $ ref：'＃/ components / schemas / Pet'
      - 类型：对象
        ＃所有其他特定于`Cat`的属性
        特性：
          名称：
            type：string
    狗：
      所有的：
      -  $ ref：'＃/ components / schemas / Pet'
      - 类型：对象
        ＃所有其他特定于`Dog`的属性
        特性：
          吠：
            type：string
    蜥蜴：
      所有的：
      -  $ ref：'＃/ components / schemas / Pet'
      - 类型：对象
        ＃所有其他特定于“蜥蜴”的属性
        特性：
          lovesRocks：
            type：布尔值
```

像这样的有效载荷：

```JSON
{
  “petType”：“猫”，
  “名字”：“有雾”
}
```

将指示使用`Cat`模式。同样这个架构：

```JSON
{
  “petType”：“狗”，
  “树皮”：“软”
}
```

由于`mappings`元素的定义，它将映射到`Dog`。


#### <a name="xmlObject"> </a> XML对象

一个元数据对象，允许更精细的XML模型定义。

使用数组时，XML元素名称是* not *推断（对于单数/复数形式），`name`属性应该用于添加该信息。
请参阅预期行为的示例。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="xmlName"> </a>名称| `string` | 替换用于描述的架构属性的元素/属性的名称。在`items`中定义时，它将影响列表中各个XML元素的名称。当`type`被定义为`array`（在`items`之外）时，它将影响包装元素，并且只有当`wrapped`为'true`时才会这样。如果`wrapped`是'false`，它将被忽略。
<a name="xmlNamespace"> </a>命名空间| `string` | 命名空间定义的URI。值必须是绝对URI的形式。
<a name="xmlPrefix"> </a>前缀| `string` | 用于[name]（＃xmlName）的前缀。
<a name="xmlAttribute"> </a>属性| `boolean` | 声明属性定义是否转换为属性而不是元素。默认值为“false”。
<a name="xmlWrapped"> </a>包裹| `boolean` | 可能只用于数组定义。表示数组是否被包装（例如，`<books> <book /> <book /> </ books>`）或unwrapped（`<book /> <book />`）。默认值为“false”。只有当`type`与`array`一起定义（在`items`之外）时，该定义才会生效。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

##### XML对象示例

XML对象定义的示例包含在[Schema Object]（＃schemaObject）的属性定义中，并带有XML表示的示例。

######没有XML元素

基本字符串属性：

```JSON
{
    “动物”： {
        “type”：“string”
    }
}
```

```YAML
动物：
  type：string
```

```XML
<动物> ... </动物>
```

基本字符串数组属性（[`wrapped`]（＃xmlWrapped）默认为“false”）：

```JSON
{
    “动物”： {
        “type”：“array”，
        “items”：{
            “type”：“string”
        }
    }
}
```

```YAML
动物：
  类型：数组
  项目：
    type：string
```

```XML
<动物> ... </动物>
<动物> ... </动物>
<动物> ... </动物>
```

###### XML名称替换

```JSON
{
  “动物”： {
    “type”：“string”，
    “xml”：{
      “名字”：“动物”
    }
  }
}
```

```YAML
动物：
  type：string
  XML：
    名称：动物
```

```XML
<动物> ... </动物>
```


###### XML属性，前缀和命名空间

在此示例中，显示了完整的模型定义。

```JSON
{
  “人”：{
    “type”：“object”，
    “properties”：{
      “ID”： {
        “type”：“整数”，
        “format”：“int32”，
        “xml”：{
          “属性”：是的
        }
      }，
      “名称”： {
        “type”：“string”，
        “xml”：{
          “namespace”：“http://example.com/schema/sample”，
          “prefix”：“sample”
        }
      }
    }
  }
}
```

```YAML
人：
  类型：对象
  特性：
    ID：
      类型：整数
      格式：int32
      XML：
        attribute：true
    名称：
      type：string
      XML：
        命名空间：http：//example.com/schema/sample
        前缀：样本
```

```XML
<Person id =“123”>
    <sample：name xmlns：sample =“http://example.com/schema/sample”> example </ sample：name>
</人>
```

###### XML数组

更改元素名称：

```JSON
{
  “动物”： {
    “type”：“array”，
    “items”：{
      “type”：“string”，
      “xml”：{
        “名字”：“动物”
      }
    }
  }
}
```

```YAML
动物：
  类型：数组
  项目：
    type：string
    XML：
      名称：动物
```

```XML
<动物>值</动物>
<动物>值</动物>
```

外部`name`属性对XML没有影响：

```JSON
{
  “动物”： {
    “type”：“array”，
    “items”：{
      “type”：“string”，
      “xml”：{
        “名字”：“动物”
      }
    }，
    “xml”：{
      “名字”：“外星人”
    }
  }
}
```

```YAML
动物：
  类型：数组
  项目：
    type：string
    XML：
      名称：动物
  XML：
    名字：外星人
```

```XML
<动物>值</动物>
<动物>值</动物>
```

即使数据被包装，如果未明确定义名称，也会在内部和外部使用相同的名称：

```JSON
{
  “动物”： {
    “type”：“array”，
    “items”：{
      “type”：“string”
    }，
    “xml”：{
      “包裹”：是的
    }
  }
}
```

```YAML
动物：
  类型：数组
  项目：
    type：string
  XML：
    包裹：真的
```

```XML
<动物>
  <动物>值</动物>
  <动物>值</动物>
</动物>
```

要克服上面示例中的命名问题，可以使用以下定义：

```JSON
{
  “动物”： {
    “type”：“array”，
    “items”：{
      “type”：“string”，
      “xml”：{
        “名字”：“动物”
      }
    }，
    “xml”：{
      “包裹”：是的
    }
  }
}
```

```YAML
动物：
  类型：数组
  项目：
    type：string
    XML：
      名称：动物
  XML：
    包裹：真的
```

```XML
<动物>
  <动物>值</动物>
  <动物>值</动物>
</动物>
```

影响内部和外部名称：

```JSON
{
  “动物”： {
    “type”：“array”，
    “items”：{
      “type”：“string”，
      “xml”：{
        “名字”：“动物”
      }
    }，
    “xml”：{
      “名字”：“外星人”，
      “包裹”：是的
    }
  }
}
```

```YAML
动物：
  类型：数组
  项目：
    type：string
    XML：
      名称：动物
  XML：
    名字：外星人
    包裹：真的
```

```XML
<外星人>
  <动物>值</动物>
  <动物>值</动物>
</外星人>
```

如果我们更改外部元素而不是内部元素：

```JSON
{
  “动物”： {
    “type”：“array”，
    “items”：{
      “type”：“string”
    }，
    “xml”：{
      “名字”：“外星人”，
      “包裹”：是的
    }
  }
}
```

```YAML
动物：
  类型：数组
  项目：
    type：string
  XML：
    名字：外星人
    包裹：真的
```

```XML
<外星人>
  <外星人>值</外星人>
  <外星人>值</外星人>
</外星人>
```

#### <a name="securitySchemeObject"> </a>安全方案对象

定义可由操作使用的安全方案。
支持的方案是HTTP身份验证，API密钥（作为标头，cookie参数或作为查询参数），OAuth2的公共流程（隐式，密码，应用程序和访问代码），如[RFC6749]（https：// tools）中所定义.ietf.org / html / rfc6749）和[OpenID Connect Discovery]（https://tools.ietf.org/html/draft-ietf-oauth-discovery-06）。

#####固定字段
字段名称| 输入| 适用于| 描述
--- |：---：| --- | ---
<a name="securitySchemeType"> </a>键入| `string` | 任何| **需要**。安全方案的类型。有效值为`“apiKey”`，``http“`，`”oauth2“`，``openIdConnect”`。
<a name="securitySchemeDescription"> </a>说明| `string` | 任何| 安全方案的简短描述。[CommonMark语法]（http://spec.commonmark.org/）可用于富文本表示。
<a name="securitySchemeName"> </a>名称| `string` | `apiKey` | **需要**。要使用的标头，查询或cookie参数的名称。
在|中使用<a name="securitySchemeIn"> </a> `string` | `apiKey` | **需要**。API密钥的位置。有效值为``query“`，``header”`或``cookie“`。
<a name="securitySchemeScheme"> </a>计划| `string` | `http` | **需要**。要在[RFC7235中定义的授权标头]中使用的HTTP授权方案的名称（https://tools.ietf.org/html/rfc7235#section-5.1）。
<a name="securitySchemeBearerFormat"> </a> bearerFormat | `string` | `http`（``bearer“`）| 向客户端提示以确定如何格式化承载令牌。承载令牌通常由授权服务器生成，因此该信息主要用于文档目的。
<a name="securitySchemeFlows"> </a>流量| [OAuth Flows Object]（＃oauthFlowsObject）| `oauth2` | **需要**。包含支持的流类型的配置信息的对象。
<a name="securitySchemeOpenIdConnectUrl"> </a> openIdConnectUrl | `string` | `openIdConnect` | **需要**。OpenId Connect URL以发现OAuth2配置值。这必须是URL的形式。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#####安全方案对象示例

######基本身份验证示例

```JSON
{
  “type”：“http”，
  “计划”：“基本”
}
```

```YAML
类型：http
方案：基本
```

###### API密钥样本

```JSON
{
  “type”：“apiKey”，
  “name”：“api_key”，
  “in”：“标题”
}
```

```YAML
类型：apiKey
名称：api_key
in：标题
```

###### JWT Bearer Sample

```JSON
{
  “type”：“http”，
  “计划”：“持票人”，
  “bearerFormat”：“JWT”，
}
```

```YAML
类型：http
计划：持票人
bearerFormat：JWT
```

######隐含的OAuth2示例

```JSON
{
  “type”：“oauth2”，
  “流动”：{
    “隐含的”：{
      “authorizationUrl”：“https://example.com/api/oauth/dialog”，
      “范围”：{
        “写：宠物”：“修改你帐户中的宠物”，
        “读：宠物”：“读你的宠物”
      }
    }
  }
}
```

```YAML
类型：oauth2
流： 
  隐：
    authorizationUrl：https：//example.com/api/oauth/dialog
    范围：
      写：宠物：在您的帐户中修改宠物
      阅读：宠物：读你的宠物
```

#### <a name="oauthFlowsObject"> </a> OAuth流对象

允许配置支持的OAuth流。

#####固定字段
字段名称| 输入| 描述
--- |：---：| ---
<a name="oauthFlowsImplicit"> </a>隐式| [OAuth Flow Object]（＃oauthFlowObject）| OAuth隐式流的配置
<a name="oauthFlowsPassword"> </a>密码| [OAuth Flow Object]（＃oauthFlowObject）| OAuth资源所有者密码流的配置
<a name="oauthFlowsClientCredentials"> </a> clientCredentials | [OAuth Flow Object]（＃oauthFlowObject）| OAuth客户端凭据流的配置。以前在OpenAPI 2.0中称为“应用程序”。
<a name="oauthFlowsAuthorizationCode"> </a> authorizationCode | [OAuth Flow Object]（＃oauthFlowObject）| OAuth授权代码流的配置。以前在OpenAPI 2.0中称为“accessCode”。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

#### <a name="oauthFlowObject"> </a> OAuth流对象

支持的OAuth流的配置详细信息

#####固定字段
字段名称| 输入| 适用于| 描述
--- |：---：| --- | ---
<a name="oauthFlowAuthorizationUrl"> </a> authorizationUrl | `string` | `oauth2`（`“implicit”`，``authorizationCode“`）| **需要**。用于此流的授权URL。这必须是URL的形式。
<a name="oauthFlowTokenUrl"> </a> tokenUrl | `string` | `oauth2`（``password“`，``clientCredentials”`，``authorizationCode“`）| **需要**。要用于此流的令牌URL。这必须是URL的形式。
<a name="oauthFlowRefreshUrl"> </a> refreshUrl | `string` | `oauth2` | 用于获取刷新令牌的URL。这必须是URL的形式。
<a name="oauthFlowScopes"> </a>范围| Map [`string`，`string`] | `oauth2` | **需要**。OAuth2安全方案的可用范围。范围名称与其简短描述之间的映射。

可以使用[Specification Extensions]（＃specificationExtensions）扩展此对象。

##### OAuth流对象示例

```JSON
{
  “type”：“oauth2”，
  “流动”：{
    “隐含的”：{
      “authorizationUrl”：“https://example.com/api/oauth/dialog”，
      “范围”：{
        “写：宠物”：“修改你帐户中的宠物”，
        “读：宠物”：“读你的宠物”
      }
    }，
    “authorizationCode”：{
      “authorizationUrl”：“https://example.com/api/oauth/dialog”，
      “tokenUrl”：“https://example.com/api/oauth/token”，
      “范围”：{
        “写：宠物”：“修改你帐户中的宠物”，
        “读：宠物”：“读你的宠物”
      }
    }
  }
}
```

```YAML
类型：oauth2
流： 
  隐：
    authorizationUrl：https：//example.com/api/oauth/dialog
    范围：
      写：宠物：在您的帐户中修改宠物
      阅读：宠物：读你的宠物
  authorizationCode：
    authorizationUrl：https：//example.com/api/oauth/dialog
    tokenUrl：https：//example.com/api/oauth/token
    范围：
      写：宠物：在您的帐户中修改宠物
      阅读：宠物：读你的宠物 
```


#### <a name="securityRequirementObject"> </a>安全要求对象

列出执行此操作所需的安全方案。
用于每个属性的名称必须对应于[组件对象]（＃componentsObject）下[安全方案]（＃componentsSecuritySchemes）中声明的安全方案。

安全要求包含多个方案的对象要求所有方案必须满足授权请求。
这样可以支持需要多个查询参数或HTTP标头来传达安全信息的方案。

当在[OpenAPI对象]（#oasObject）或[Operation Object]（＃operationObject）上定义安全需求对象列表时，只需要满足列表中的一个安全需求对象来授权请求​​。

#####图案化字段

场模式| 输入| 描述
--- |：---：| ---
<a name="securityRequirementsName"> </a> {name} | [`string`] | 每个名称必须对应于在[Components Object]（＃componentsObject）下的[Security Schemes]（＃componentsSecuritySchemes）中声明的安全方案。如果安全方案的类型为“oauth2”或“openIdConnect”，那么该值是执行所需的范围名称列表。对于其他安全方案类型，数组必须为空。

#####安全要求对象示例

######非OAuth2安全要求

```JSON
{
  “api_key”：[]
}
```

```YAML
api_key：[]
```

###### OAuth2安全要求

```JSON
{
  “petstore_auth”：[
    “写：宠物”，
    “读：宠物”
  ]
}
```

```YAML
petstore_auth：
- 写：宠物
- 阅读：宠物
```

### <a name="specificationExtensions"> </a>规范扩展

虽然OpenAPI规范试图适应大多数用例，但可以添加额外的数据以在某些点扩展规范。

扩展属性实现为图案化字段，始终以“x-”为前缀。

场模式| 输入| 描述
--- |：---：| ---
<a name="infoExtensions"> </a> ^ x- | 任何| 允许扩展OpenAPI架构。字段名必须以`x-`开头，例如`x-internal-id`。值可以是“null”，基元，数组或对象。可以具有任何有效的JSON格式值。

可用工具可能支持或不支持扩展，但也可以扩展这些扩展以添加请求的支持（如果工具是内部工具或开源工具）。

### <a name="securityFiltering"> </a>安全过滤

OpenAPI规范中的某些对象可以声明并保持为空，或者被完全删除，即使它们本身就是API文档的核心。 

原因是允许对文档进行额外的访问控制。
虽然不是规范本身的一部分，但某些库可能会选择允许基于某种形式的身份验证/授权来访问部分文档。

两个例子：

1. [Paths Object]（＃pathsObject）可能为空。这可能违反直觉，但这可能告诉观众他们到了正确的地方，但无法访问任何文档。他们仍然可以访问[Info Object]（#infoObject），其中可能包含有关身份验证的其他信息。
2. [Path Item Object]（＃pathItemObject）可以为空。在这种情况下，查看者将意识到路径存在，但将无法看到其任何操作或参数。这与将路径本身隐藏在[Paths Object]（#pathPath）中不同，因此用户不会意识到它的存在。这允许文档提供者精确控制观看者可以看到的内容。

## <a name="revisionHistory"> </a>附录A：修订历史记录

版本| 日期| 笔记
--- | --- | ---
3.0.2 | 2018-10-08 | OpenAPI规范3.0.2的补丁版本
3.0.1 | 2017-12-06 | OpenAPI规范3.0.1的补丁版本
3.0.0 | 2017-07-26 | 发布OpenAPI规范3.0.0
3.0.0-rc2 | 2017-06-16 | 3.0规范的rc2
3.0.0-rc1 | 2017-04-27 | 3.0规范的rc1
3.0.0-rc0 | 2017-02-28 | 实施者的3.0规范草案
2.0 | 2015-12-31 | 向开放API计划捐赠Swagger 2.0
2.0 | 2014-09-08 | 发布Swagger 2.0
1.2 | 2014-03-14 | 正式文件的初始发布。
1.1 | 2012-08-22 | 发布Swagger 1.1
1.0 | 2011-08-10 | Swagger规范的首次发布